<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_13">
  <title>Chapter 12: Monitoring, Observability, and Reliability</title>
  <body>
    <section><title>Table of Contents</title></section>
    <ul>
      <li>
        12.1 Observability Overview
      </li>
      <li>
        12.2 Structured Logging
      </li>
      <li>
        12.3 Distributed Tracing
      </li>
      <li>
        12.4 Metrics Collection
      </li>
      <li>
        12.5 Error Tracking and Alerting
      </li>
      <li>
        12.6 Health Checks
      </li>
      <li>
        12.7 Reliability Patterns
      </li>
      <li>
        12.8 Dashboards and Visualization
      </li>
      <li>
        Exercises
      </li>
      <li>
        Summary
      </li>
    </ul>
    <section><title>12.1 Observability Overview</title></section>
    <p>Observability is the ability to understand what&apos;s happening inside your system by examining its outputs. For AI systems, this is critical because of non-deterministic behavior and complex failure modes.</p>
    <section><title>The Three Pillars of Observability</title></section>
    <codeblock outputclass="language-typescript">/**
 * The three pillars of observability
 */
export enum ObservabilityPillar {
  /** Logs: Discrete events with context */
  LOGS = &apos;logs&apos;,

  /** Metrics: Numerical measurements over time */
  METRICS = &apos;metrics&apos;,

  /** Traces: Request flow through system */
  TRACES = &apos;traces&apos;
}

/**
 * Observability requirements for AI systems
 */
export const OBSERVABILITY_REQUIREMENTS = {
  logs: {
    structured: true,        // Machine-parseable format
    contextual: true,        // Include request/user context
    searchable: true,        // Full-text search capability
    retention: 30,           // Days to retain
    sampling: false          // No sampling (capture all)
  },

  metrics: {
    granularity: 60,         // Seconds between measurements
    dimensions: [            // Metric dimensions
      &apos;provider&apos;,
      &apos;model&apos;,
      &apos;operation&apos;,
      &apos;status&apos;
    ],
    aggregations: [          // Aggregation types
      &apos;sum&apos;,
      &apos;avg&apos;,
      &apos;p50&apos;,
      &apos;p95&apos;,
      &apos;p99&apos;
    ]
  },

  traces: {
    sampleRate: 1.0,         // 100% sampling in production
    includeContext: true,    // Include full request context
    maxSpans: 1000,          // Max spans per trace
    retention: 7             // Days to retain
  }
};
</codeblock>
    <section><title>Observability Goals</title></section>
    <codeblock outputclass="language-typescript">/**
 * What we want to know about our AI system
 */
export interface ObservabilityGoals {
  // Performance
  howFast: {
    firstTokenLatency: number;    // Time to first token
    totalLatency: number;         // Total request time
    cacheHitRate: number;         // Cache effectiveness
  };

  // Reliability
  howReliable: {
    errorRate: number;            // % of requests failing
    availability: number;         // % uptime
    successRate: number;          // % of successful requests
  };

  // Cost
  howExpensive: {
    costPerRequest: number;       // Average cost
    totalCost: number;            // Total spend
    tokenUsage: number;           // Tokens consumed
  };

  // Quality
  howGood: {
    qualityScore: number;         // Output quality (0-100)
    userSatisfaction: number;     // User feedback
    regressionRate: number;       // % quality regressions
  };

  // Usage
  whoAndWhat: {
    activeUsers: number;          // Users in time period
    requestsPerUser: number;      // Usage per user
    topOperations: string[];      // Most common operations
  };
}
</codeblock>
    <section><title>Before vs After Observability</title></section>
    <codeblock outputclass="language-typescript">/**
 * Without observability
 */
function withoutObservability() {
  // User reports issue
  console.log(&apos;User: My request failed&apos;);

  // You have no visibility
  // - No logs to check
  // - No metrics to analyze
  // - No trace to follow
  // - No error details

  // Result: 60+ minutes debugging
  // - Checking code
  // - Adding console.log
  // - Reproducing locally
  // - Guessing root cause
}

/**
 * With observability
 */
async function withObservability() {
  // User reports issue
  console.log(&apos;User: My request failed at 14:32&apos;);

  // Check dashboard
  const trace = await tracing.getTrace(&apos;req_abc123&apos;);

  console.log(`
ðŸ“Š Request Trace: req_abc123
â”œâ”€ User: user_456
â”œâ”€ Timestamp: 2024-01-15 14:32:15
â”œâ”€ Duration: 3,456ms
â”œâ”€ Status: FAILED
â”œâ”€
â”œâ”€ Spans:
â”‚  â”œâ”€ [200ms] Validate Input âœ“
â”‚  â”œâ”€ [150ms] Check Cache âœ“ (miss)
â”‚  â”œâ”€ [2,100ms] AI Provider: Anthropic
â”‚  â”‚  â”œâ”€ Status: 429 Rate Limit
â”‚  â”‚  â””â”€ Error: Rate limit exceeded
â”‚  â”œâ”€ [890ms] Fallback: OpenAI âœ“
â”‚  â”‚  â””â”€ Success
â”‚  â””â”€ [116ms] Cache Result âœ“
â”œâ”€
â”œâ”€ Root Cause: Anthropic rate limit
â”œâ”€ Resolution: Fallback succeeded
â””â”€ Action Taken: Increased rate limit
  `);

  // Result: 2 minutes to identify and resolve
}
</codeblock>
    <section><title>12.2 Structured Logging</title></section>
    <p>Structured logging uses machine-parseable formats (JSON) instead of plain text, enabling powerful querying and analysis.</p>
    <section><title>Structured Logger</title></section>
    <codeblock outputclass="language-typescript">import winston from &apos;winston&apos;;

/**
 * Structured logger with context
 */
export class StructuredLogger {
  private logger: winston.Logger;

  constructor(options: LoggerOptions = {}) {
    this.logger = winston.createLogger({
      level: options.level || &apos;info&apos;,
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: {
        service: options.service || &apos;ollama-code&apos;,
        environment: process.env.NODE_ENV || &apos;development&apos;,
        version: options.version || &apos;1.0.0&apos;
      },
      transports: [
        // Console (for development)
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        }),

        // File (for production)
        new winston.transports.File({
          filename: &apos;logs/error.log&apos;,
          level: &apos;error&apos;
        }),
        new winston.transports.File({
          filename: &apos;logs/combined.log&apos;
        })
      ]
    });
  }

  /**
   * Log with context
   */
  info(message: string, context?: LogContext): void {
    this.logger.info(message, this.enrichContext(context));
  }

  warn(message: string, context?: LogContext): void {
    this.logger.warn(message, this.enrichContext(context));
  }

  error(message: string, error?: Error, context?: LogContext): void {
    this.logger.error(message, {
      ...this.enrichContext(context),
      error: error ? {
        message: error.message,
        stack: error.stack,
        name: error.name
      } : undefined
    });
  }

  debug(message: string, context?: LogContext): void {
    this.logger.debug(message, this.enrichContext(context));
  }

  /**
   * Enrich context with metadata
   */
  private enrichContext(context?: LogContext): Record&lt;string, any&gt; {
    return {
      ...context,
      timestamp: new Date().toISOString(),
      pid: process.pid,
      hostname: require(&apos;os&apos;).hostname()
    };
  }

  /**
   * Create child logger with fixed context
   */
  child(context: LogContext): StructuredLogger {
    const child = new StructuredLogger({
      service: this.logger.defaultMeta?.service,
      level: this.logger.level
    });

    // Add fixed context to all logs
    child.logger.defaultMeta = {
      ...child.logger.defaultMeta,
      ...context
    };

    return child;
  }
}

interface LoggerOptions {
  service?: string;
  level?: string;
  version?: string;
}

interface LogContext {
  requestId?: string;
  userId?: string;
  operation?: string;
  duration?: number;
  [key: string]: any;
}
</codeblock>
    <section><title>Request Logger</title></section>
    <codeblock outputclass="language-typescript">/**
 * Logs AI requests with full context
 */
export class RequestLogger {
  constructor(private logger: StructuredLogger) {}

  /**
   * Log AI request start
   */
  logRequestStart(request: CompletionRequest, context: RequestContext): void {
    this.logger.info(&apos;AI request started&apos;, {
      requestId: context.requestId,
      userId: context.userId,
      provider: request.model?.split(&apos;/&apos;)[0],
      model: request.model,
      messageCount: request.messages.length,
      temperature: request.temperature,
      maxTokens: request.maxTokens,
      operation: context.operation
    });
  }

  /**
   * Log AI request completion
   */
  logRequestComplete(
    request: CompletionRequest,
    response: CompletionResponse,
    context: RequestContext,
    duration: number
  ): void {
    this.logger.info(&apos;AI request completed&apos;, {
      requestId: context.requestId,
      userId: context.userId,
      provider: response.metadata?.provider,
      model: response.model,
      duration,
      inputTokens: response.usage?.inputTokens,
      outputTokens: response.usage?.outputTokens,
      totalTokens: response.usage?.totalTokens,
      cost: this.calculateCost(response),
      fromCache: response.metadata?.fromCache || false,
      operation: context.operation
    });
  }

  /**
   * Log AI request error
   */
  logRequestError(
    request: CompletionRequest,
    error: Error,
    context: RequestContext,
    duration: number
  ): void {
    this.logger.error(&apos;AI request failed&apos;, error, {
      requestId: context.requestId,
      userId: context.userId,
      model: request.model,
      duration,
      operation: context.operation,
      errorType: error.name,
      retryable: this.isRetryable(error)
    });
  }

  /**
   * Log tool execution
   */
  logToolExecution(
    tool: string,
    params: Record&lt;string, any&gt;,
    result: ToolResult,
    duration: number,
    context: RequestContext
  ): void {
    this.logger.info(&apos;Tool executed&apos;, {
      requestId: context.requestId,
      tool,
      params: this.sanitizeParams(params),
      success: result.success,
      duration,
      fromCache: result.fromCache || false,
      operation: context.operation
    });
  }

  /**
   * Calculate request cost
   */
  private calculateCost(response: CompletionResponse): number {
    if (!response.usage) return 0;

    // Approximate costs (would use actual provider pricing)
    const inputCost = response.usage.inputTokens * 0.00001;
    const outputCost = response.usage.outputTokens * 0.00003;

    return inputCost + outputCost;
  }

  /**
   * Check if error is retryable
   */
  private isRetryable(error: Error): boolean {
    const retryableErrors = [
      &apos;RateLimitError&apos;,
      &apos;TimeoutError&apos;,
      &apos;NetworkError&apos;,
      &apos;ServiceUnavailableError&apos;
    ];

    return retryableErrors.includes(error.name);
  }

  /**
   * Sanitize sensitive parameters
   */
  private sanitizeParams(params: Record&lt;string, any&gt;): Record&lt;string, any&gt; {
    const sanitized = { ...params };

    // Redact sensitive fields
    const sensitiveFields = [&apos;apiKey&apos;, &apos;password&apos;, &apos;token&apos;, &apos;secret&apos;];

    for (const field of sensitiveFields) {
      if (field in sanitized) {
        sanitized[field] = &apos;[REDACTED]&apos;;
      }
    }

    return sanitized;
  }
}

interface RequestContext {
  requestId: string;
  userId?: string;
  operation: string;
}
</codeblock>
    <section><title>Log Querying</title></section>
    <codeblock outputclass="language-typescript">/**
 * Query structured logs
 */
export class LogQuery {
  constructor(private logsPath: string) {}

  /**
   * Query logs by criteria
   */
  async query(criteria: QueryCriteria): Promise&lt;LogEntry[]&gt; {
    const logs = await this.readLogs();

    return logs.filter(log =&gt; {
      // Filter by time range
      if (criteria.startTime &amp;&amp; new Date(log.timestamp) &lt; criteria.startTime) {
        return false;
      }

      if (criteria.endTime &amp;&amp; new Date(log.timestamp) &gt; criteria.endTime) {
        return false;
      }

      // Filter by level
      if (criteria.level &amp;&amp; log.level !== criteria.level) {
        return false;
      }

      // Filter by service
      if (criteria.service &amp;&amp; log.service !== criteria.service) {
        return false;
      }

      // Filter by request ID
      if (criteria.requestId &amp;&amp; log.requestId !== criteria.requestId) {
        return false;
      }

      // Filter by user ID
      if (criteria.userId &amp;&amp; log.userId !== criteria.userId) {
        return false;
      }

      // Filter by operation
      if (criteria.operation &amp;&amp; log.operation !== criteria.operation) {
        return false;
      }

      return true;
    });
  }

  /**
   * Get error rate
   */
  async getErrorRate(timeRange: TimeRange): Promise&lt;number&gt; {
    const logs = await this.query({
      startTime: timeRange.start,
      endTime: timeRange.end
    });

    const errors = logs.filter(log =&gt; log.level === &apos;error&apos;).length;
    const total = logs.length;

    return total &gt; 0 ? errors / total : 0;
  }

  /**
   * Get average duration
   */
  async getAverageDuration(
    operation: string,
    timeRange: TimeRange
  ): Promise&lt;number&gt; {
    const logs = await this.query({
      operation,
      startTime: timeRange.start,
      endTime: timeRange.end
    });

    const durations = logs
      .filter(log =&gt; log.duration !== undefined)
      .map(log =&gt; log.duration!);

    if (durations.length === 0) return 0;

    return durations.reduce((a, b) =&gt; a + b, 0) / durations.length;
  }

  /**
   * Read logs from file
   */
  private async readLogs(): Promise&lt;LogEntry[]&gt; {
    const content = await fs.readFile(this.logsPath, &apos;utf-8&apos;);
    const lines = content.split(&apos;\n&apos;).filter(line =&gt; line.trim());

    return lines.map(line =&gt; JSON.parse(line));
  }
}

interface QueryCriteria {
  startTime?: Date;
  endTime?: Date;
  level?: string;
  service?: string;
  requestId?: string;
  userId?: string;
  operation?: string;
}

interface TimeRange {
  start: Date;
  end: Date;
}

interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  service: string;
  requestId?: string;
  userId?: string;
  operation?: string;
  duration?: number;
  [key: string]: any;
}
</codeblock>
    <section><title>12.3 Distributed Tracing</title></section>
    <p>Distributed tracing tracks requests as they flow through your system, showing the complete call graph.</p>
    <section><title>Trace Context</title></section>
    <codeblock outputclass="language-typescript">/**
 * Trace context for distributed tracing
 */
export class TraceContext {
  constructor(
    public readonly traceId: string,
    public readonly spanId: string,
    public readonly parentSpanId?: string
  ) {}

  /**
   * Create root trace context
   */
  static createRoot(): TraceContext {
    return new TraceContext(
      this.generateId(),
      this.generateId()
    );
  }

  /**
   * Create child span
   */
  createChild(): TraceContext {
    return new TraceContext(
      this.traceId,
      TraceContext.generateId(),
      this.spanId
    );
  }

  /**
   * Generate unique ID
   */
  private static generateId(): string {
    return crypto.randomBytes(16).toString(&apos;hex&apos;);
  }
}
</codeblock>
    <section><title>Tracer</title></section>
    <codeblock outputclass="language-typescript">/**
 * Distributed tracer
 */
export class Tracer {
  private spans: Map&lt;string, Span&gt; = new Map();
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
  }

  /**
   * Start a span
   */
  startSpan(
    name: string,
    context: TraceContext,
    attributes?: Record&lt;string, any&gt;
  ): Span {
    const span: Span = {
      traceId: context.traceId,
      spanId: context.spanId,
      parentSpanId: context.parentSpanId,
      name,
      startTime: Date.now(),
      attributes: attributes || {},
      events: [],
      status: SpanStatus.UNSET
    };

    this.spans.set(span.spanId, span);

    this.logger.debug(&apos;Span started&apos;, {
      traceId: span.traceId,
      spanId: span.spanId,
      name: span.name
    });

    return span;
  }

  /**
   * End a span
   */
  endSpan(span: Span, status: SpanStatus = SpanStatus.OK): void {
    span.endTime = Date.now();
    span.duration = span.endTime - span.startTime;
    span.status = status;

    this.logger.info(&apos;Span completed&apos;, {
      traceId: span.traceId,
      spanId: span.spanId,
      name: span.name,
      duration: span.duration,
      status: span.status
    });

    // Export span to trace collector
    this.exportSpan(span);
  }

  /**
   * Add event to span
   */
  addEvent(span: Span, name: string, attributes?: Record&lt;string, any&gt;): void {
    span.events.push({
      name,
      timestamp: Date.now(),
      attributes: attributes || {}
    });
  }

  /**
   * Set span error
   */
  setError(span: Span, error: Error): void {
    span.status = SpanStatus.ERROR;
    span.attributes.error = {
      message: error.message,
      stack: error.stack,
      name: error.name
    };
  }

  /**
   * Get trace
   */
  async getTrace(traceId: string): Promise&lt;Trace&gt; {
    const spans = Array.from(this.spans.values())
      .filter(s =&gt; s.traceId === traceId)
      .sort((a, b) =&gt; a.startTime - b.startTime);

    return {
      traceId,
      spans,
      duration: this.calculateTraceDuration(spans),
      status: this.calculateTraceStatus(spans)
    };
  }

  /**
   * Export span to trace collector
   */
  private exportSpan(span: Span): void {
    // Would export to OpenTelemetry, Jaeger, etc.
    // For now, just log
    this.logger.debug(&apos;Span exported&apos;, {
      span: JSON.stringify(span)
    });
  }

  /**
   * Calculate total trace duration
   */
  private calculateTraceDuration(spans: Span[]): number {
    if (spans.length === 0) return 0;

    const start = Math.min(...spans.map(s =&gt; s.startTime));
    const end = Math.max(...spans.map(s =&gt; s.endTime || s.startTime));

    return end - start;
  }

  /**
   * Calculate trace status
   */
  private calculateTraceStatus(spans: Span[]): SpanStatus {
    if (spans.some(s =&gt; s.status === SpanStatus.ERROR)) {
      return SpanStatus.ERROR;
    }

    return SpanStatus.OK;
  }
}

interface Span {
  traceId: string;
  spanId: string;
  parentSpanId?: string;
  name: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  attributes: Record&lt;string, any&gt;;
  events: SpanEvent[];
  status: SpanStatus;
}

interface SpanEvent {
  name: string;
  timestamp: number;
  attributes: Record&lt;string, any&gt;;
}

enum SpanStatus {
  UNSET = &apos;unset&apos;,
  OK = &apos;ok&apos;,
  ERROR = &apos;error&apos;
}

interface Trace {
  traceId: string;
  spans: Span[];
  duration: number;
  status: SpanStatus;
}
</codeblock>
    <section><title>Traced AI Service</title></section>
    <codeblock outputclass="language-typescript">/**
 * AI service with distributed tracing
 */
export class TracedAIService {
  constructor(
    private provider: AIProvider,
    private tracer: Tracer,
    private logger: StructuredLogger
  ) {}

  /**
   * Complete with tracing
   */
  async complete(
    request: CompletionRequest,
    context: TraceContext
  ): Promise&lt;CompletionResponse&gt; {
    // Create span for AI request
    const span = this.tracer.startSpan(&apos;ai.complete&apos;, context, {
      provider: this.provider.constructor.name,
      model: request.model,
      messageCount: request.messages.length,
      temperature: request.temperature
    });

    try {
      // Add event for request start
      this.tracer.addEvent(span, &apos;request.started&apos;, {
        inputTokens: this.estimateTokens(request.messages)
      });

      // Call AI provider
      const response = await this.provider.complete(request);

      // Add event for response
      this.tracer.addEvent(span, &apos;response.received&apos;, {
        outputTokens: response.usage?.outputTokens,
        fromCache: response.metadata?.fromCache
      });

      // Update span attributes
      span.attributes.outputTokens = response.usage?.outputTokens;
      span.attributes.totalTokens = response.usage?.totalTokens;
      span.attributes.cost = this.calculateCost(response);

      // End span successfully
      this.tracer.endSpan(span, SpanStatus.OK);

      return response;

    } catch (error) {
      // Record error in span
      this.tracer.setError(span, error as Error);
      this.tracer.endSpan(span, SpanStatus.ERROR);

      throw error;
    }
  }

  /**
   * Execute tool with tracing
   */
  async executeTool(
    tool: Tool,
    params: Record&lt;string, any&gt;,
    context: TraceContext
  ): Promise&lt;ToolResult&gt; {
    // Create child span for tool
    const childContext = context.createChild();
    const span = this.tracer.startSpan(`tool.${tool.name}`, childContext, {
      tool: tool.name,
      params: this.sanitizeParams(params)
    });

    try {
      const result = await tool.execute(params, {
        traceContext: childContext
      });

      span.attributes.success = result.success;
      span.attributes.fromCache = result.fromCache || false;

      this.tracer.endSpan(span, SpanStatus.OK);

      return result;

    } catch (error) {
      this.tracer.setError(span, error as Error);
      this.tracer.endSpan(span, SpanStatus.ERROR);

      throw error;
    }
  }

  private estimateTokens(messages: Message[]): number {
    return messages.reduce((total, msg) =&gt; {
      return total + msg.content.split(/\s+/).length;
    }, 0);
  }

  private calculateCost(response: CompletionResponse): number {
    if (!response.usage) return 0;

    const inputCost = response.usage.inputTokens * 0.00001;
    const outputCost = response.usage.outputTokens * 0.00003;

    return inputCost + outputCost;
  }

  private sanitizeParams(params: Record&lt;string, any&gt;): Record&lt;string, any&gt; {
    // Redact sensitive fields
    const sanitized = { ...params };
    const sensitiveFields = [&apos;apiKey&apos;, &apos;password&apos;, &apos;token&apos;];

    for (const field of sensitiveFields) {
      if (field in sanitized) {
        sanitized[field] = &apos;[REDACTED]&apos;;
      }
    }

    return sanitized;
  }
}
</codeblock>
    <section><title>12.4 Metrics Collection</title></section>
    <p>Collect numerical metrics over time to track performance, usage, and costs.</p>
    <section><title>Metrics Collector</title></section>
    <codeblock outputclass="language-typescript">/**
 * Collects and aggregates metrics
 */
export class MetricsCollector {
  private metrics: Map&lt;string, Metric[]&gt; = new Map();
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
  }

  /**
   * Record a counter metric
   */
  incrementCounter(
    name: string,
    value: number = 1,
    tags?: Record&lt;string, string&gt;
  ): void {
    this.recordMetric({
      name,
      type: MetricType.COUNTER,
      value,
      tags: tags || {},
      timestamp: Date.now()
    });
  }

  /**
   * Record a gauge metric
   */
  setGauge(
    name: string,
    value: number,
    tags?: Record&lt;string, string&gt;
  ): void {
    this.recordMetric({
      name,
      type: MetricType.GAUGE,
      value,
      tags: tags || {},
      timestamp: Date.now()
    });
  }

  /**
   * Record a histogram metric
   */
  recordHistogram(
    name: string,
    value: number,
    tags?: Record&lt;string, string&gt;
  ): void {
    this.recordMetric({
      name,
      type: MetricType.HISTOGRAM,
      value,
      tags: tags || {},
      timestamp: Date.now()
    });
  }

  /**
   * Record a timing metric
   */
  recordTiming(
    name: string,
    durationMs: number,
    tags?: Record&lt;string, string&gt;
  ): void {
    this.recordHistogram(name, durationMs, tags);
  }

  /**
   * Store metric
   */
  private recordMetric(metric: Metric): void {
    if (!this.metrics.has(metric.name)) {
      this.metrics.set(metric.name, []);
    }

    this.metrics.get(metric.name)!.push(metric);

    // Log metric
    this.logger.debug(&apos;Metric recorded&apos;, {
      metric: metric.name,
      value: metric.value,
      type: metric.type,
      tags: metric.tags
    });
  }

  /**
   * Get metric statistics
   */
  getStats(
    name: string,
    timeRange: TimeRange
  ): MetricStats | null {
    const metrics = this.metrics.get(name);

    if (!metrics) return null;

    // Filter by time range
    const filtered = metrics.filter(m =&gt;
      m.timestamp &gt;= timeRange.start.getTime() &amp;&amp;
      m.timestamp &lt;= timeRange.end.getTime()
    );

    if (filtered.length === 0) return null;

    const values = filtered.map(m =&gt; m.value).sort((a, b) =&gt; a - b);

    return {
      count: filtered.length,
      sum: values.reduce((a, b) =&gt; a + b, 0),
      avg: values.reduce((a, b) =&gt; a + b, 0) / values.length,
      min: values[0],
      max: values[values.length - 1],
      p50: values[Math.floor(values.length * 0.5)],
      p95: values[Math.floor(values.length * 0.95)],
      p99: values[Math.floor(values.length * 0.99)]
    };
  }

  /**
   * Export metrics to monitoring system
   */
  exportMetrics(): void {
    // Would export to Prometheus, CloudWatch, etc.
    for (const [name, metrics] of this.metrics.entries()) {
      this.logger.info(&apos;Exporting metrics&apos;, {
        metric: name,
        count: metrics.length
      });
    }
  }
}

enum MetricType {
  COUNTER = &apos;counter&apos;,
  GAUGE = &apos;gauge&apos;,
  HISTOGRAM = &apos;histogram&apos;
}

interface Metric {
  name: string;
  type: MetricType;
  value: number;
  tags: Record&lt;string, string&gt;;
  timestamp: number;
}

interface MetricStats {
  count: number;
  sum: number;
  avg: number;
  min: number;
  max: number;
  p50: number;
  p95: number;
  p99: number;
}
</codeblock>
    <section><title>Key Metrics for AI Systems</title></section>
    <codeblock outputclass="language-typescript">/**
 * Tracks key metrics for AI systems
 */
export class AIMetrics {
  constructor(private collector: MetricsCollector) {}

  /**
   * Record request metrics
   */
  recordRequest(
    provider: string,
    duration: number,
    success: boolean,
    cached: boolean
  ): void {
    // Request count
    this.collector.incrementCounter(&apos;ai.requests.total&apos;, 1, {
      provider,
      status: success ? &apos;success&apos; : &apos;error&apos;,
      cached: cached.toString()
    });

    // Request duration
    this.collector.recordTiming(&apos;ai.requests.duration&apos;, duration, {
      provider
    });

    // Cache hit rate
    if (cached) {
      this.collector.incrementCounter(&apos;ai.cache.hits&apos;, 1, { provider });
    } else {
      this.collector.incrementCounter(&apos;ai.cache.misses&apos;, 1, { provider });
    }
  }

  /**
   * Record token usage
   */
  recordTokens(
    provider: string,
    inputTokens: number,
    outputTokens: number
  ): void {
    this.collector.incrementCounter(&apos;ai.tokens.input&apos;, inputTokens, {
      provider
    });

    this.collector.incrementCounter(&apos;ai.tokens.output&apos;, outputTokens, {
      provider
    });
  }

  /**
   * Record cost
   */
  recordCost(provider: string, cost: number): void {
    this.collector.incrementCounter(&apos;ai.cost.total&apos;, cost, {
      provider
    });
  }

  /**
   * Record error
   */
  recordError(provider: string, errorType: string): void {
    this.collector.incrementCounter(&apos;ai.errors.total&apos;, 1, {
      provider,
      errorType
    });
  }

  /**
   * Record tool execution
   */
  recordToolExecution(
    tool: string,
    duration: number,
    success: boolean
  ): void {
    this.collector.incrementCounter(&apos;tools.executions.total&apos;, 1, {
      tool,
      status: success ? &apos;success&apos; : &apos;error&apos;
    });

    this.collector.recordTiming(&apos;tools.executions.duration&apos;, duration, {
      tool
    });
  }

  /**
   * Record memory usage
   */
  recordMemoryUsage(): void {
    const usage = process.memoryUsage();

    this.collector.setGauge(&apos;system.memory.heap_used&apos;, usage.heapUsed);
    this.collector.setGauge(&apos;system.memory.heap_total&apos;, usage.heapTotal);
    this.collector.setGauge(&apos;system.memory.external&apos;, usage.external);
    this.collector.setGauge(&apos;system.memory.rss&apos;, usage.rss);
  }
}
</codeblock>
    <section><title>12.5 Error Tracking and Alerting</title></section>
    <p>Track errors and send alerts when issues occur.</p>
    <section><title>Error Tracker</title></section>
    <codeblock outputclass="language-typescript">/**
 * Tracks and categorizes errors
 */
export class ErrorTracker {
  private errors: Map&lt;string, ErrorEntry[]&gt; = new Map();
  private logger: StructuredLogger;
  private alerting: AlertingService;

  constructor(
    logger: StructuredLogger,
    alerting: AlertingService
  ) {
    this.logger = logger;
    this.alerting = alerting;
  }

  /**
   * Track error
   */
  async trackError(
    error: Error,
    context: ErrorContext
  ): Promise&lt;void&gt; {
    const entry: ErrorEntry = {
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context,
      timestamp: Date.now(),
      fingerprint: this.generateFingerprint(error, context)
    };

    // Store error
    if (!this.errors.has(entry.fingerprint)) {
      this.errors.set(entry.fingerprint, []);
    }

    this.errors.get(entry.fingerprint)!.push(entry);

    // Log error
    this.logger.error(&apos;Error tracked&apos;, error, {
      fingerprint: entry.fingerprint,
      operation: context.operation,
      requestId: context.requestId
    });

    // Check if alert needed
    await this.checkAlerts(entry.fingerprint);
  }

  /**
   * Generate error fingerprint for grouping
   */
  private generateFingerprint(error: Error, context: ErrorContext): string {
    // Group errors by name, message pattern, and operation
    const parts = [
      error.name,
      this.normalizeMessage(error.message),
      context.operation
    ];

    return crypto
      .createHash(&apos;sha256&apos;)
      .update(parts.join(&apos;:&apos;))
      .digest(&apos;hex&apos;)
      .substring(0, 16);
  }

  /**
   * Normalize error message to group similar errors
   */
  private normalizeMessage(message: string): string {
    return message
      .replace(/\d+/g, &apos;N&apos;)           // Numbers -&gt; N
      .replace(/[a-f0-9-]{36}/g, &apos;UUID&apos;) // UUIDs -&gt; UUID
      .replace(/&quot;[^&quot;]*&quot;/g, &apos;STR&apos;);    // Strings -&gt; STR
  }

  /**
   * Check if alerts should be sent
   */
  private async checkAlerts(fingerprint: string): Promise&lt;void&gt; {
    const errors = this.errors.get(fingerprint) || [];

    // Alert on first occurrence
    if (errors.length === 1) {
      await this.alerting.send({
        severity: AlertSeverity.INFO,
        title: &apos;New error type detected&apos;,
        message: `${errors[0].error.name}: ${errors[0].error.message}`,
        context: errors[0].context
      });
    }

    // Alert on spike (&gt;10 in last 5 minutes)
    const recentErrors = errors.filter(
      e =&gt; Date.now() - e.timestamp &lt; 5 * 60 * 1000
    );

    if (recentErrors.length &gt;= 10) {
      await this.alerting.send({
        severity: AlertSeverity.WARNING,
        title: &apos;Error spike detected&apos;,
        message: `${recentErrors.length} occurrences in 5 minutes`,
        context: errors[0].context
      });
    }

    // Alert on sustained high rate (&gt;50 in last hour)
    const lastHourErrors = errors.filter(
      e =&gt; Date.now() - e.timestamp &lt; 60 * 60 * 1000
    );

    if (lastHourErrors.length &gt;= 50) {
      await this.alerting.send({
        severity: AlertSeverity.CRITICAL,
        title: &apos;High error rate&apos;,
        message: `${lastHourErrors.length} occurrences in last hour`,
        context: errors[0].context
      });
    }
  }

  /**
   * Get error statistics
   */
  getStats(timeRange: TimeRange): ErrorStats {
    let totalErrors = 0;
    const errorsByType = new Map&lt;string, number&gt;();
    const errorsByOperation = new Map&lt;string, number&gt;();

    for (const [fingerprint, entries] of this.errors.entries()) {
      const filtered = entries.filter(
        e =&gt; e.timestamp &gt;= timeRange.start.getTime() &amp;&amp;
             e.timestamp &lt;= timeRange.end.getTime()
      );

      totalErrors += filtered.length;

      for (const entry of filtered) {
        // Count by type
        const type = entry.error.name;
        errorsByType.set(type, (errorsByType.get(type) || 0) + 1);

        // Count by operation
        const op = entry.context.operation;
        errorsByOperation.set(op, (errorsByOperation.get(op) || 0) + 1);
      }
    }

    return {
      totalErrors,
      uniqueErrors: this.errors.size,
      errorsByType: Object.fromEntries(errorsByType),
      errorsByOperation: Object.fromEntries(errorsByOperation)
    };
  }
}

interface ErrorEntry {
  error: {
    name: string;
    message: string;
    stack?: string;
  };
  context: ErrorContext;
  timestamp: number;
  fingerprint: string;
}

interface ErrorContext {
  requestId?: string;
  userId?: string;
  operation: string;
  [key: string]: any;
}

interface ErrorStats {
  totalErrors: number;
  uniqueErrors: number;
  errorsByType: Record&lt;string, number&gt;;
  errorsByOperation: Record&lt;string, number&gt;;
}
</codeblock>
    <section><title>Alerting Service</title></section>
    <codeblock outputclass="language-typescript">/**
 * Sends alerts via multiple channels
 */
export class AlertingService {
  private channels: AlertChannel[] = [];
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
  }

  /**
   * Add alert channel
   */
  addChannel(channel: AlertChannel): void {
    this.channels.push(channel);
  }

  /**
   * Send alert
   */
  async send(alert: Alert): Promise&lt;void&gt; {
    this.logger.info(&apos;Sending alert&apos;, {
      severity: alert.severity,
      title: alert.title
    });

    // Send to all channels
    await Promise.all(
      this.channels.map(channel =&gt; channel.send(alert))
    );
  }
}

interface Alert {
  severity: AlertSeverity;
  title: string;
  message: string;
  context?: Record&lt;string, any&gt;;
}

enum AlertSeverity {
  INFO = &apos;info&apos;,
  WARNING = &apos;warning&apos;,
  CRITICAL = &apos;critical&apos;
}

interface AlertChannel {
  send(alert: Alert): Promise&lt;void&gt;;
}

/**
 * Slack alert channel
 */
export class SlackAlertChannel implements AlertChannel {
  constructor(private webhookUrl: string) {}

  async send(alert: Alert): Promise&lt;void&gt; {
    const color = {
      [AlertSeverity.INFO]: &apos;#36a64f&apos;,
      [AlertSeverity.WARNING]: &apos;#ff9900&apos;,
      [AlertSeverity.CRITICAL]: &apos;#ff0000&apos;
    }[alert.severity];

    await fetch(this.webhookUrl, {
      method: &apos;POST&apos;,
      headers: { &apos;Content-Type&apos;: &apos;application/json&apos; },
      body: JSON.stringify({
        attachments: [{
          color,
          title: alert.title,
          text: alert.message,
          fields: alert.context ? Object.entries(alert.context).map(([key, value]) =&gt; ({
            title: key,
            value: String(value),
            short: true
          })) : []
        }]
      })
    });
  }
}

/**
 * Email alert channel
 */
export class EmailAlertChannel implements AlertChannel {
  constructor(private emailService: any) {}

  async send(alert: Alert): Promise&lt;void&gt; {
    await this.emailService.send({
      to: &apos;ops@example.com&apos;,
      subject: `[${alert.severity.toUpperCase()}] ${alert.title}`,
      body: alert.message
    });
  }
}
</codeblock>
    <section><title>12.6 Health Checks</title></section>
    <p>Health checks verify system components are working correctly.</p>
    <section><title>Health Check System</title></section>
    <codeblock outputclass="language-typescript">/**
 * Health check system
 */
export class HealthCheckSystem {
  private checks: Map&lt;string, HealthCheck&gt; = new Map();
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
  }

  /**
   * Register health check
   */
  register(name: string, check: HealthCheck): void {
    this.checks.set(name, check);
  }

  /**
   * Run all health checks
   */
  async runAll(): Promise&lt;HealthReport&gt; {
    const results: Record&lt;string, HealthCheckResult&gt; = {};

    for (const [name, check] of this.checks.entries()) {
      try {
        const startTime = performance.now();

        const result = await Promise.race([
          check.check(),
          this.timeout(5000) // 5 second timeout
        ]);

        const duration = performance.now() - startTime;

        results[name] = {
          status: result ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY,
          duration,
          message: result ? &apos;OK&apos; : &apos;Failed&apos;
        };

      } catch (error) {
        results[name] = {
          status: HealthStatus.UNHEALTHY,
          duration: 0,
          message: (error as Error).message
        };
      }
    }

    const overallStatus = Object.values(results).every(
      r =&gt; r.status === HealthStatus.HEALTHY
    ) ? HealthStatus.HEALTHY : HealthStatus.UNHEALTHY;

    return {
      status: overallStatus,
      checks: results,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Timeout helper
   */
  private timeout(ms: number): Promise&lt;never&gt; {
    return new Promise((_, reject) =&gt;
      setTimeout(() =&gt; reject(new Error(&apos;Health check timeout&apos;)), ms)
    );
  }
}

interface HealthCheck {
  check(): Promise&lt;boolean&gt;;
}

interface HealthCheckResult {
  status: HealthStatus;
  duration: number;
  message: string;
}

enum HealthStatus {
  HEALTHY = &apos;healthy&apos;,
  UNHEALTHY = &apos;unhealthy&apos;,
  DEGRADED = &apos;degraded&apos;
}

interface HealthReport {
  status: HealthStatus;
  checks: Record&lt;string, HealthCheckResult&gt;;
  timestamp: string;
}
</codeblock>
    <section><title>Common Health Checks</title></section>
    <codeblock outputclass="language-typescript">/**
 * Database health check
 */
export class DatabaseHealthCheck implements HealthCheck {
  constructor(private db: any) {}

  async check(): Promise&lt;boolean&gt; {
    try {
      await this.db.query(&apos;SELECT 1&apos;);
      return true;
    } catch (error) {
      return false;
    }
  }
}

/**
 * AI provider health check
 */
export class AIProviderHealthCheck implements HealthCheck {
  constructor(private provider: AIProvider) {}

  async check(): Promise&lt;boolean&gt; {
    try {
      const health = await this.provider.healthCheck();
      return health.healthy;
    } catch (error) {
      return false;
    }
  }
}

/**
 * Disk space health check
 */
export class DiskSpaceHealthCheck implements HealthCheck {
  constructor(private minFreeGB: number = 1) {}

  async check(): Promise&lt;boolean&gt; {
    const { available } = await import(&apos;fs&apos;).promises.statfs(&apos;/&apos;);
    const freeGB = available / 1024 / 1024 / 1024;

    return freeGB &gt;= this.minFreeGB;
  }
}

/**
 * Memory health check
 */
export class MemoryHealthCheck implements HealthCheck {
  constructor(private maxUsagePercent: number = 80) {}

  async check(): Promise&lt;boolean&gt; {
    const usage = process.memoryUsage();
    const usagePercent = (usage.heapUsed / usage.heapTotal) * 100;

    return usagePercent &lt; this.maxUsagePercent;
  }
}
</codeblock>
    <section><title>12.7 Reliability Patterns</title></section>
    <p>Implement patterns that improve system reliability.</p>
    <section><title>Circuit Breaker</title></section>
    <codeblock outputclass="language-typescript">/**
 * Circuit breaker prevents cascading failures
 */
export class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures = 0;
  private lastFailureTime = 0;
  private successCount = 0;

  constructor(
    private options: CircuitBreakerOptions,
    private logger: StructuredLogger
  ) {}

  /**
   * Execute function with circuit breaker
   */
  async execute&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {
    // Check circuit state
    if (this.state === CircuitState.OPEN) {
      // Check if we should try again
      if (Date.now() - this.lastFailureTime &gt;= this.options.resetTimeout) {
        this.logger.info(&apos;Circuit breaker: Entering half-open state&apos;);
        this.state = CircuitState.HALF_OPEN;
      } else {
        throw new Error(&apos;Circuit breaker is OPEN&apos;);
      }
    }

    try {
      const result = await fn();

      // Success
      this.onSuccess();

      return result;

    } catch (error) {
      // Failure
      this.onFailure();

      throw error;
    }
  }

  /**
   * Handle success
   */
  private onSuccess(): void {
    this.failures = 0;

    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;

      if (this.successCount &gt;= this.options.successThreshold) {
        this.logger.info(&apos;Circuit breaker: Closing circuit&apos;);
        this.state = CircuitState.CLOSED;
        this.successCount = 0;
      }
    }
  }

  /**
   * Handle failure
   */
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.failures &gt;= this.options.failureThreshold) {
      this.logger.warn(&apos;Circuit breaker: Opening circuit&apos;, {
        failures: this.failures
      });

      this.state = CircuitState.OPEN;
    }
  }

  /**
   * Get circuit state
   */
  getState(): CircuitState {
    return this.state;
  }
}

enum CircuitState {
  CLOSED = &apos;closed&apos;,     // Normal operation
  OPEN = &apos;open&apos;,         // Reject all requests
  HALF_OPEN = &apos;half_open&apos; // Try limited requests
}

interface CircuitBreakerOptions {
  failureThreshold: number;    // Failures before opening
  successThreshold: number;    // Successes before closing
  resetTimeout: number;        // ms before trying again
}
</codeblock>
    <section><title>Retry with Exponential Backoff</title></section>
    <codeblock outputclass="language-typescript">/**
 * Retry failed operations with exponential backoff
 */
export class RetryPolicy {
  constructor(
    private options: RetryOptions,
    private logger: StructuredLogger
  ) {}

  /**
   * Execute with retry
   */
  async execute&lt;T&gt;(fn: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt; {
    let lastError: Error | undefined;

    for (let attempt = 0; attempt &lt; this.options.maxAttempts; attempt++) {
      try {
        return await fn();

      } catch (error) {
        lastError = error as Error;

        // Check if retryable
        if (!this.isRetryable(error as Error)) {
          throw error;
        }

        // Last attempt - don&apos;t wait
        if (attempt === this.options.maxAttempts - 1) {
          break;
        }

        // Calculate backoff
        const backoffMs = this.calculateBackoff(attempt);

        this.logger.info(&apos;Retrying after error&apos;, {
          attempt: attempt + 1,
          maxAttempts: this.options.maxAttempts,
          backoffMs,
          error: (error as Error).message
        });

        // Wait before retry
        await this.sleep(backoffMs);
      }
    }

    throw lastError;
  }

  /**
   * Check if error is retryable
   */
  private isRetryable(error: Error): boolean {
    const retryableErrors = [
      &apos;RateLimitError&apos;,
      &apos;TimeoutError&apos;,
      &apos;NetworkError&apos;,
      &apos;ServiceUnavailableError&apos;
    ];

    return retryableErrors.includes(error.name);
  }

  /**
   * Calculate exponential backoff
   */
  private calculateBackoff(attempt: number): number {
    const baseDelay = this.options.baseDelayMs || 1000;
    const maxDelay = this.options.maxDelayMs || 30000;

    // Exponential: baseDelay * 2^attempt
    let delay = baseDelay * Math.pow(2, attempt);

    // Add jitter to prevent thundering herd
    if (this.options.jitter) {
      delay = delay * (0.5 + Math.random() * 0.5);
    }

    // Cap at max delay
    return Math.min(delay, maxDelay);
  }

  private sleep(ms: number): Promise&lt;void&gt; {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
  }
}

interface RetryOptions {
  maxAttempts: number;
  baseDelayMs?: number;
  maxDelayMs?: number;
  jitter?: boolean;
}
</codeblock>
    <section><title>12.8 Dashboards and Visualization</title></section>
    <p>Create dashboards to visualize metrics and system health.</p>
    <section><title>Dashboard Data Provider</title></section>
    <codeblock outputclass="language-typescript">/**
 * Provides data for dashboards
 */
export class DashboardDataProvider {
  constructor(
    private metrics: MetricsCollector,
    private logs: LogQuery,
    private tracer: Tracer
  ) {}

  /**
   * Get overview metrics
   */
  async getOverview(timeRange: TimeRange): Promise&lt;DashboardOverview&gt; {
    return {
      requests: await this.getRequestMetrics(timeRange),
      errors: await this.getErrorMetrics(timeRange),
      performance: await this.getPerformanceMetrics(timeRange),
      cost: await this.getCostMetrics(timeRange)
    };
  }

  /**
   * Get request metrics
   */
  private async getRequestMetrics(timeRange: TimeRange): Promise&lt;RequestMetrics&gt; {
    const totalRequests = this.metrics.getStats(&apos;ai.requests.total&apos;, timeRange);
    const successRate = await this.calculateSuccessRate(timeRange);
    const cacheHitRate = await this.calculateCacheHitRate(timeRange);

    return {
      total: totalRequests?.count || 0,
      successRate,
      cacheHitRate
    };
  }

  /**
   * Get error metrics
   */
  private async getErrorMetrics(timeRange: TimeRange): Promise&lt;ErrorMetrics&gt; {
    const errorRate = await this.logs.getErrorRate(timeRange);
    const errorStats = await this.logs.query({
      level: &apos;error&apos;,
      startTime: timeRange.start,
      endTime: timeRange.end
    });

    return {
      rate: errorRate,
      total: errorStats.length
    };
  }

  /**
   * Get performance metrics
   */
  private async getPerformanceMetrics(timeRange: TimeRange): Promise&lt;PerformanceMetrics&gt; {
    const durationStats = this.metrics.getStats(&apos;ai.requests.duration&apos;, timeRange);

    return {
      avgLatency: durationStats?.avg || 0,
      p95Latency: durationStats?.p95 || 0,
      p99Latency: durationStats?.p99 || 0
    };
  }

  /**
   * Get cost metrics
   */
  private async getCostMetrics(timeRange: TimeRange): Promise&lt;CostMetrics&gt; {
    const costStats = this.metrics.getStats(&apos;ai.cost.total&apos;, timeRange);
    const tokenStats = this.metrics.getStats(&apos;ai.tokens.input&apos;, timeRange);

    return {
      total: costStats?.sum || 0,
      avgPerRequest: costStats?.avg || 0,
      totalTokens: tokenStats?.sum || 0
    };
  }

  private async calculateSuccessRate(timeRange: TimeRange): Promise&lt;number&gt; {
    // Implementation would query actual metrics
    return 0.98; // 98% success rate
  }

  private async calculateCacheHitRate(timeRange: TimeRange): Promise&lt;number&gt; {
    const hits = this.metrics.getStats(&apos;ai.cache.hits&apos;, timeRange);
    const misses = this.metrics.getStats(&apos;ai.cache.misses&apos;, timeRange);

    const totalHits = hits?.sum || 0;
    const totalMisses = misses?.sum || 0;
    const total = totalHits + totalMisses;

    return total &gt; 0 ? totalHits / total : 0;
  }
}

interface DashboardOverview {
  requests: RequestMetrics;
  errors: ErrorMetrics;
  performance: PerformanceMetrics;
  cost: CostMetrics;
}

interface RequestMetrics {
  total: number;
  successRate: number;
  cacheHitRate: number;
}

interface ErrorMetrics {
  rate: number;
  total: number;
}

interface PerformanceMetrics {
  avgLatency: number;
  p95Latency: number;
  p99Latency: number;
}

interface CostMetrics {
  total: number;
  avgPerRequest: number;
  totalTokens: number;
}
</codeblock>
    <section><title>Exercises</title></section>
    <section><title>Exercise 1: Build a Real-Time Dashboard</title></section>
    <p><b>Goal:</b> Create a real-time dashboard showing system metrics.</p>
    <p><b>Requirements:</b>
1. Display key metrics (requests/sec, error rate, latency)
2. Auto-refresh every 10 seconds
3. Show trends (up/down arrows)
4. Highlight anomalies
5. Export to JSON</p>
    <section><title>Exercise 2: Implement SLO Tracking</title></section>
    <p><b>Goal:</b> Track Service Level Objectives (SLOs) and alert on violations.</p>
    <p><b>Requirements:</b>
1. Define SLOs (e.g., 99% requests &lt; 2s)
2. Track error budgets
3. Calculate SLO compliance
4. Alert when SLO at risk
5. Generate SLO reports</p>
    <section><title>Exercise 3: Create Incident Response System</title></section>
    <p><b>Goal:</b> Automate incident detection and response.</p>
    <p><b>Requirements:</b>
1. Detect incidents from metrics/logs
2. Create incident record
3. Send alerts to on-call
4. Track MTTR (Mean Time To Resolution)
5. Generate post-mortems</p>
    <section><title>Summary</title></section>
    <p>In this chapter, you built comprehensive observability for your AI assistant.</p>
    <section><title>Key Concepts</title></section>
    <ol>
      <li>
        <b>Structured Logging</b>
        - Machine-parseable logs with full context
      </li>
      <li>
        <b>Distributed Tracing</b>
        - Track requests through entire system
      </li>
      <li>
        <b>Metrics Collection</b>
        - Track performance, cost, and usage
      </li>
      <li>
        <b>Error Tracking</b>
        - Categorize and alert on errors
      </li>
      <li>
        <b>Health Checks</b>
        - Verify system components
      </li>
      <li>
        <b>Reliability Patterns</b>
        - Circuit breaker, retry, fallback
      </li>
      <li>
        <b>Dashboards</b>
        - Visualize system health
      </li>
    </ol>
    <section><title>Observability Stack</title></section>
    <codeblock>Logs (Structured JSON)
â”œâ”€ What happened
â”œâ”€ Full context
â””â”€ Searchable

Metrics (Time Series)
â”œâ”€ How much/how fast
â”œâ”€ Trends over time
â””â”€ Alerting

Traces (Request Flow)
â”œâ”€ Where time spent
â”œâ”€ Bottleneck identification
â””â”€ Error propagation
</codeblock>
    <section><title>Real-World Impact</title></section>
    <p><b>Before Observability:</b>
- 60+ minutes to debug issues
- No visibility into performance
- Reactive incident response
- Unknown cost drivers</p>
    <p><b>After Observability:</b>
- 2 minutes to identify root cause
- Real-time performance monitoring
- Proactive issue detection
- Complete cost visibility</p>
    <section><title>Production Readiness Achieved!</title></section>
    <p>With Parts I-IV complete, you now have a production-ready AI coding assistant:</p>
    <ul>
      <li>
        âœ…
        <b>Part I</b>
        : Multi-provider AI, DI, services
      </li>
      <li>
        âœ…
        <b>Part II</b>
        : Tools, streaming, conversations
      </li>
      <li>
        âœ…
        <b>Part III</b>
        : VCS, NL routing, security
      </li>
      <li>
        âœ…
        <b>Part IV</b>
        : Testing, performance, observability
      </li>
    </ul>
    <section><title>Next Steps</title></section>
    <p>In <b>Part V: Extensibility</b>, you&apos;ll learn how to extend your system with plugins, IDE integrations, and custom tools.</p>
    <p><i>Chapter 12 | Monitoring, Observability, and Reliability | Complete</i>
<i>Part IV | Production Readiness | Complete</i></p>
  </body>
</topic>