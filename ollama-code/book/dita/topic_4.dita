<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_4">
  <title>Chapter 4: Tool Orchestration and Execution</title>
  <body>
    <section><title>Introduction</title></section>
    <p>In the previous chapters, we built a solid foundation for AI coding assistants: multi-provider integration, dependency injection, and service management. Now we face a critical question: <b>How do we enable AI to actually DO things?</b></p>
    <p>An AI that can only chat is like a mechanic who can diagnose problems but can&apos;t pick up a wrench. The real power of AI coding assistants comes from their ability to execute actions:</p>
    <ul>
      <li>
        Read and analyze files
      </li>
      <li>
        Make code modifications
      </li>
      <li>
        Execute git commands
      </li>
      <li>
        Run tests and builds
      </li>
      <li>
        Search codebases
      </li>
      <li>
        Create pull requests
      </li>
    </ul>
    <p><b>Tool orchestration</b> is the architectural pattern that enables AI agents to interact with the world through well-defined, composable tools. This chapter explores how to design, implement, and orchestrate tools that are:</p>
    <ul>
      <li>
        <b>Safe</b>
        - Tools require approval for destructive operations
      </li>
      <li>
        <b>Efficient</b>
        - Parallel execution and result caching
      </li>
      <li>
        <b>Reliable</b>
        - Robust error handling and recovery
      </li>
      <li>
        <b>Composable</b>
        - Tools can depend on other tools
      </li>
      <li>
        <b>Observable</b>
        - Full visibility into tool execution
      </li>
    </ul>
    <section><title>What You&apos;ll Learn</title></section>
    <p>By the end of this chapter, you&apos;ll understand:</p>
    <ol>
      <li>
        <b>Tool System Architecture</b>
        - How tools fit into the overall system
      </li>
      <li>
        <b>Tool Interface Design</b>
        - Creating clean, composable tool contracts
      </li>
      <li>
        <b>Tool Implementations</b>
        - File system, git, and code analysis tools
      </li>
      <li>
        <b>Dependency Resolution</b>
        - Building and executing dependency graphs
      </li>
      <li>
        <b>Parallel Execution</b>
        - Optimizing performance with concurrency
      </li>
      <li>
        <b>Result Caching</b>
        - Avoiding redundant work
      </li>
      <li>
        <b>Interactive Approval</b>
        - Safety mechanisms for destructive operations
      </li>
      <li>
        <b>Error Handling</b>
        - Graceful degradation and recovery strategies
      </li>
    </ol>
    <section><title>4.1 Tool System Overview</title></section>
    <section><title>The Problem</title></section>
    <p>AI models excel at understanding natural language and generating text, but they can&apos;t directly interact with file systems, execute commands, or modify code. We need a bridge between AI reasoning and real-world actions.</p>
    <p>Consider this user request:</p>
    <codeblock>User: &quot;Find all TODO comments in the codebase and create GitHub issues for them&quot;
</codeblock>
    <p>To fulfill this request, an AI coding assistant needs to:</p>
    <ol>
      <li>
        <b>Search</b>
        the codebase for TODO comments (
        <codeph>search_code</codeph>
        tool)
      </li>
      <li>
        <b>Read</b>
        files containing TODOs to get context (
        <codeph>read_file</codeph>
        tool)
      </li>
      <li>
        <b>Extract</b>
        TODO information and categorize by priority
      </li>
      <li>
        <b>Create</b>
        GitHub issues via API (
        <codeph>create_github_issue</codeph>
        tool)
      </li>
      <li>
        <b>Link</b>
        code locations to the created issues
      </li>
    </ol>
    <p>Without tools, the AI can only provide instructions. With tools, the AI can execute the entire workflow autonomously.</p>
    <section><title>The Solution: Tool Orchestration</title></section>
    <p>Tool orchestration provides:</p>
    <ol>
      <li>
        <b>Tool Abstraction</b>
        - Common interface for all tools
      </li>
      <li>
        <b>Dependency Management</b>
        - Tools can depend on other tools
      </li>
      <li>
        <b>Execution Planning</b>
        - Optimal execution order
      </li>
      <li>
        <b>Parallel Execution</b>
        - Run independent tools concurrently
      </li>
      <li>
        <b>Result Caching</b>
        - Avoid redundant operations
      </li>
      <li>
        <b>Safety Mechanisms</b>
        - Approval workflows for destructive operations
      </li>
      <li>
        <b>Progress Tracking</b>
        - Real-time visibility into execution
      </li>
      <li>
        <b>Error Recovery</b>
        - Graceful handling of failures
      </li>
    </ol>
    <section><title>Architecture Overview</title></section>
    <p>Here&apos;s how tool orchestration fits into the overall system:</p>
    <codeblock>┌─────────────────────────────────────────────────────────────┐
│                     AI Coding Assistant                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Conversation Manager                       │
│  - Receives user request                                     │
│  - Analyzes intent: &quot;Find TODOs and create issues&quot;           │
│  - Sends to AI with available tools                          │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      AI Provider                             │
│  - Reasons about the task                                    │
│  - Decides which tools to use                                │
│  - Returns tool calls: [search_code, read_file, ...]         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Tool Orchestrator                          │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 1. Dependency Resolution                             │   │
│  │    - Build dependency graph                          │   │
│  │    - Detect circular dependencies                    │   │
│  │    - Determine execution order                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 2. Execution Planning                                │   │
│  │    - Identify parallel execution opportunities       │   │
│  │    - Check result cache                              │   │
│  │    - Request approval for destructive operations     │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 3. Execution                                         │   │
│  │    - Execute tools in optimal order                  │   │
│  │    - Run independent tools in parallel               │   │
│  │    - Cache results                                   │   │
│  │    - Handle errors and retries                       │   │
│  └─────────────────────────────────────────────────────┘   │
│                              │                                │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ 4. Result Aggregation                                │   │
│  │    - Collect all tool results                        │   │
│  │    - Track metrics (duration, cache hits, etc.)      │   │
│  │    - Return to AI for next reasoning step            │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      Tool Registry                           │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  File Tools  │  │  Git Tools   │  │ Code Tools   │      │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤      │
│  │ read_file    │  │ git_status   │  │ search_code  │      │
│  │ write_file   │  │ git_diff     │  │ analyze_ast  │      │
│  │ list_files   │  │ git_commit   │  │ find_refs    │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
</codeblock>
    <section><title>Key Concepts</title></section>
    <section><title>1. Tool Definition</title></section>
    <p>A tool is a discrete unit of functionality with:</p>
    <codeblock outputclass="language-typescript">interface Tool {
  // Unique identifier
  name: string;

  // Human-readable description for AI
  description: string;

  // JSON Schema for parameters
  parameters: ToolParameters;

  // Tools this tool depends on
  dependencies?: string[];

  // Whether this tool requires user approval
  requiresApproval?: boolean;

  // Whether results should be cached
  cacheable?: boolean;

  // Execute the tool
  execute(params: any): Promise&lt;ToolResult&gt;;
}
</codeblock>
    <section><title>2. Tool Call</title></section>
    <p>When an AI decides to use a tool, it returns a tool call:</p>
    <codeblock outputclass="language-typescript">interface ToolCall {
  // Unique ID for this specific tool call
  id: string;

  // Tool to execute
  toolName: string;

  // Parameters to pass
  parameters: any;

  // Optional: Depends on results from other tool calls
  dependsOn?: string[];
}
</codeblock>
    <section><title>3. Tool Result</title></section>
    <p>After execution, a tool returns a result:</p>
    <codeblock outputclass="language-typescript">interface ToolResult {
  // ID of the tool call
  callId: string;

  // Success or failure
  success: boolean;

  // Result data (if successful)
  data?: any;

  // Error information (if failed)
  error?: {
    message: string;
    code?: string;
    recoverable: boolean;
  };

  // Execution metadata
  metadata: {
    durationMs: number;
    cached: boolean;
    retriesAttempted?: number;
  };
}
</codeblock>
    <section><title>Example: End-to-End Flow</title></section>
    <p>Let&apos;s trace a complete tool execution flow:</p>
    <codeblock outputclass="language-typescript">// User request
&quot;Find all TODOs in src/ and create GitHub issues&quot;

// 1. AI Provider returns tool calls
const toolCalls: ToolCall[] = [
  {
    id: &apos;call_1&apos;,
    toolName: &apos;search_code&apos;,
    parameters: {
      pattern: &apos;TODO:&apos;,
      path: &apos;src/&apos;,
      includeContext: true
    }
  },
  {
    id: &apos;call_2&apos;,
    toolName: &apos;read_file&apos;,
    parameters: {
      path: &apos;${call_1.results[0].file}&apos; // Depends on search results
    },
    dependsOn: [&apos;call_1&apos;]
  },
  {
    id: &apos;call_3&apos;,
    toolName: &apos;create_github_issue&apos;,
    parameters: {
      title: &apos;TODO: ${call_2.todoContent}&apos;,
      body: &apos;${call_2.context}&apos;,
      labels: [&apos;technical-debt&apos;]
    },
    dependsOn: [&apos;call_2&apos;],
    requiresApproval: true // User must approve issue creation
  }
];

// 2. Tool Orchestrator processes calls
const orchestrator = new ToolOrchestrator(toolRegistry);
const results = await orchestrator.execute(toolCalls, {
  parallelExecution: true,
  enableCache: true,
  approvalCallback: async (call) =&gt; {
    // Show user what will be done
    console.log(`Create GitHub issue: ${call.parameters.title}?`);
    return await promptUser(&apos;Approve? (y/n)&apos;);
  }
});

// 3. Results returned to AI
// AI can now respond to user with summary:
// &quot;✓ Found 15 TODOs
//  ✓ Created 15 GitHub issues
//  📊 Issues: #101-#115&quot;
</codeblock>
    <section><title>4.2 Tool Interface Design</title></section>
    <section><title>Core Tool Interface</title></section>
    <p>The foundation of tool orchestration is a clean, consistent interface. Here&apos;s the complete tool contract:</p>
    <codeblock outputclass="language-typescript">/**
 * Tool parameter definition using JSON Schema
 */
export interface ToolParameters {
  type: &apos;object&apos;;
  properties: Record&lt;string, {
    type: string;
    description: string;
    enum?: string[];
    required?: boolean;
  }&gt;;
  required?: string[];
}

/**
 * Tool execution context
 * Provides tools with access to system services
 */
export interface ToolContext {
  // Working directory
  workingDirectory: string;

  // Logger for tool output
  logger: Logger;

  // Access to other tools (for composition)
  toolRegistry: ToolRegistry;

  // User preferences
  preferences: UserPreferences;

  // Cancellation token
  cancellationToken?: CancellationToken;
}

/**
 * Base tool interface
 * All tools must implement this
 */
export interface Tool {
  /**
   * Unique tool identifier
   * Example: &apos;read_file&apos;, &apos;git_commit&apos;, &apos;search_code&apos;
   */
  readonly name: string;

  /**
   * Description for AI model
   * Should explain what the tool does and when to use it
   */
  readonly description: string;

  /**
   * Parameter schema (JSON Schema format)
   * Used for validation and AI parameter generation
   */
  readonly parameters: ToolParameters;

  /**
   * Tools this tool depends on
   * Example: &apos;write_file&apos; might depend on &apos;read_file&apos;
   */
  readonly dependencies?: string[];

  /**
   * Whether this tool requires user approval
   * True for destructive operations (write, delete, commit, etc.)
   */
  readonly requiresApproval?: boolean;

  /**
   * Whether results should be cached
   * True for read-only, deterministic operations
   */
  readonly cacheable?: boolean;

  /**
   * Maximum execution time in milliseconds
   * Tool will be cancelled if it exceeds this
   */
  readonly timeoutMs?: number;

  /**
   * Whether this tool can be retried on failure
   */
  readonly retryable?: boolean;

  /**
   * Execute the tool
   *
   * @param params - Validated parameters
   * @param context - Execution context
   * @returns Tool result
   */
  execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt;;

  /**
   * Validate parameters before execution
   * Optional: If not provided, uses JSON Schema validation
   *
   * @param params - Parameters to validate
   * @returns Validation result
   */
  validate?(params: any): ValidationResult;

  /**
   * Estimate cost/complexity of execution
   * Used for routing and optimization decisions
   *
   * @param params - Tool parameters
   * @returns Estimated cost (arbitrary units)
   */
  estimateCost?(params: any): number;
}

/**
 * Validation result
 */
export interface ValidationResult {
  valid: boolean;
  errors?: Array&lt;{
    field: string;
    message: string;
  }&gt;;
}

/**
 * Tool execution result
 */
export interface ToolResult {
  // ID of the tool call that produced this result
  callId: string;

  // Tool name
  toolName: string;

  // Success/failure status
  success: boolean;

  // Result data (if successful)
  data?: any;

  // Error information (if failed)
  error?: ToolError;

  // Execution metadata
  metadata: ToolMetadata;
}

/**
 * Tool error information
 */
export interface ToolError {
  // Human-readable error message
  message: string;

  // Error code for programmatic handling
  code?: string;

  // Whether the error is recoverable via retry
  recoverable: boolean;

  // Suggested fix or workaround
  suggestion?: string;

  // Stack trace (in development mode)
  stack?: string;
}

/**
 * Tool execution metadata
 */
export interface ToolMetadata {
  // Execution duration in milliseconds
  durationMs: number;

  // Whether result was served from cache
  cached: boolean;

  // Number of retry attempts
  retriesAttempted?: number;

  // Timestamp of execution
  timestamp: Date;

  // Whether user approval was required and granted
  approvalGranted?: boolean;

  // Additional tool-specific metadata
  [key: string]: any;
}
</codeblock>
    <section><title>Design Principles</title></section>
    <section><title>1. Declarative Over Imperative</title></section>
    <p>Tools should declare their capabilities and requirements, not implement orchestration logic:</p>
    <p><b>✅ Good:</b></p>
    <codeblock outputclass="language-typescript">export class WriteFileTool implements Tool {
  name = &apos;write_file&apos;;
  description = &apos;Write content to a file&apos;;
  requiresApproval = true; // Declarative
  cacheable = false; // Declarative
  dependencies = [&apos;read_file&apos;]; // Declarative

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    // Just do the work, orchestrator handles approval/caching/dependencies
    await fs.writeFile(params.path, params.content);
    return { success: true, data: { bytesWritten: params.content.length } };
  }
}
</codeblock>
    <p><b>❌ Bad:</b></p>
    <codeblock outputclass="language-typescript">export class WriteFileTool implements Tool {
  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    // Imperative - tool shouldn&apos;t handle this
    const approved = await this.requestApproval(params);
    if (!approved) {
      throw new Error(&apos;Approval denied&apos;);
    }

    // Imperative - orchestrator should handle caching
    const cached = await this.checkCache(params);
    if (cached) return cached;

    await fs.writeFile(params.path, params.content);
  }
}
</codeblock>
    <section><title>2. Single Responsibility</title></section>
    <p>Each tool should do ONE thing well:</p>
    <p><b>✅ Good:</b></p>
    <codeblock outputclass="language-typescript">// Separate tools for separate concerns
class ReadFileTool implements Tool {
  name = &apos;read_file&apos;;
  async execute(params) {
    return await fs.readFile(params.path, &apos;utf-8&apos;);
  }
}

class WriteFileTool implements Tool {
  name = &apos;write_file&apos;;
  async execute(params) {
    await fs.writeFile(params.path, params.content);
  }
}

class EditFileTool implements Tool {
  name = &apos;edit_file&apos;;
  async execute(params) {
    // Uses read_file and write_file internally
  }
}
</codeblock>
    <p><b>❌ Bad:</b></p>
    <codeblock outputclass="language-typescript">// One tool doing too much
class FileOperationTool implements Tool {
  name = &apos;file_operation&apos;;
  async execute(params) {
    if (params.operation === &apos;read&apos;) {
      // Read logic
    } else if (params.operation === &apos;write&apos;) {
      // Write logic
    } else if (params.operation === &apos;delete&apos;) {
      // Delete logic
    }
    // Hard to cache, approve, compose
  }
}
</codeblock>
    <section><title>3. Composability</title></section>
    <p>Tools should be composable - complex tools can use simpler tools:</p>
    <codeblock outputclass="language-typescript">export class RefactorTool implements Tool {
  name = &apos;refactor_code&apos;;
  description = &apos;Refactor code using AST transformations&apos;;
  dependencies = [&apos;read_file&apos;, &apos;analyze_ast&apos;, &apos;write_file&apos;];

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    // 1. Read current file
    const content = await context.toolRegistry
      .get(&apos;read_file&apos;)
      .execute({ path: params.path }, context);

    // 2. Analyze AST
    const ast = await context.toolRegistry
      .get(&apos;analyze_ast&apos;)
      .execute({ code: content.data }, context);

    // 3. Transform AST
    const transformed = this.transformAST(ast.data, params.transformation);

    // 4. Write back
    return await context.toolRegistry
      .get(&apos;write_file&apos;)
      .execute({ path: params.path, content: transformed }, context);
  }
}
</codeblock>
    <section><title>4. Rich Error Information</title></section>
    <p>Tools should provide actionable error information:</p>
    <codeblock outputclass="language-typescript">export class GitCommitTool implements Tool {
  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    try {
      await git.commit(params.message);
      return { success: true, data: { commitHash: &apos;...&apos; } };
    } catch (error) {
      // Detect specific error conditions
      if (error.message.includes(&apos;nothing to commit&apos;)) {
        return {
          success: false,
          error: {
            message: &apos;No changes to commit&apos;,
            code: &apos;NOTHING_TO_COMMIT&apos;,
            recoverable: false,
            suggestion: &apos;Make changes to files before committing, or check git status&apos;
          }
        };
      } else if (error.message.includes(&apos;Please tell me who you are&apos;)) {
        return {
          success: false,
          error: {
            message: &apos;Git user not configured&apos;,
            code: &apos;GIT_USER_NOT_CONFIGURED&apos;,
            recoverable: true,
            suggestion: &apos;Run: git config --global user.name &quot;Your Name&quot; &amp;&amp; git config --global user.email &quot;your@email.com&quot;&apos;
          }
        };
      }

      // Unknown error
      return {
        success: false,
        error: {
          message: error.message,
          code: &apos;UNKNOWN_ERROR&apos;,
          recoverable: true,
          stack: error.stack
        }
      };
    }
  }
}
</codeblock>
    <section><title>Tool Categories</title></section>
    <p>Tools typically fall into these categories:</p>
    <section><title>1. Read-Only Tools</title></section>
    <ul>
      <li>
        Safe, cacheable, no approval needed
      </li>
      <li>
        Examples:
        <codeph>read_file</codeph>
        ,
        <codeph>list_files</codeph>
        ,
        <codeph>git_status</codeph>
        ,
        <codeph>search_code</codeph>
      </li>
    </ul>
    <codeblock outputclass="language-typescript">export abstract class ReadOnlyTool implements Tool {
  readonly requiresApproval = false;
  readonly cacheable = true;
  readonly retryable = true;
}
</codeblock>
    <section><title>2. Mutation Tools</title></section>
    <ul>
      <li>
        Require approval, not cacheable
      </li>
      <li>
        Examples:
        <codeph>write_file</codeph>
        ,
        <codeph>delete_file</codeph>
        ,
        <codeph>git_commit</codeph>
        ,
        <codeph>create_pr</codeph>
      </li>
    </ul>
    <codeblock outputclass="language-typescript">export abstract class MutationTool implements Tool {
  readonly requiresApproval = true;
  readonly cacheable = false;
  readonly retryable = false; // Don&apos;t retry writes
}
</codeblock>
    <section><title>3. Analysis Tools</title></section>
    <ul>
      <li>
        Computationally expensive, cacheable
      </li>
      <li>
        Examples:
        <codeph>analyze_ast</codeph>
        ,
        <codeph>find_references</codeph>
        ,
        <codeph>calculate_metrics</codeph>
      </li>
    </ul>
    <codeblock outputclass="language-typescript">export abstract class AnalysisTool implements Tool {
  readonly requiresApproval = false;
  readonly cacheable = true;
  readonly retryable = true;
  readonly timeoutMs = 30000; // 30 second timeout
}
</codeblock>
    <section><title>4. External Tools</title></section>
    <ul>
      <li>
        Call external APIs, may require approval
      </li>
      <li>
        Examples:
        <codeph>create_github_issue</codeph>
        ,
        <codeph>deploy_to_production</codeph>
        ,
        <codeph>send_notification</codeph>
      </li>
    </ul>
    <codeblock outputclass="language-typescript">export abstract class ExternalTool implements Tool {
  readonly requiresApproval = true; // Depends on operation
  readonly cacheable = false; // External state changes
  readonly retryable = true; // Can retry failed API calls
}
</codeblock>
    <section><title>4.3 Tool Implementations</title></section>
    <p>Now let&apos;s implement concrete tools across different categories. We&apos;ll build file system tools, git tools, and code analysis tools.</p>
    <section><title>File System Tools</title></section>
    <section><title>Read File Tool</title></section>
    <codeblock outputclass="language-typescript">import * as fs from &apos;fs/promises&apos;;
import * as path from &apos;path&apos;;

export class ReadFileTool implements Tool {
  readonly name = &apos;read_file&apos;;
  readonly description = &apos;Read the contents of a file&apos;;
  readonly requiresApproval = false;
  readonly cacheable = true;
  readonly retryable = true;

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      path: {
        type: &apos;string&apos;,
        description: &apos;Path to the file to read (relative to working directory)&apos;
      },
      encoding: {
        type: &apos;string&apos;,
        description: &apos;File encoding (default: utf-8)&apos;,
        enum: [&apos;utf-8&apos;, &apos;ascii&apos;, &apos;base64&apos;]
      }
    },
    required: [&apos;path&apos;]
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const encoding = params.encoding || &apos;utf-8&apos;;
    const filePath = path.resolve(context.workingDirectory, params.path);

    try {
      // Security: Ensure file is within working directory
      if (!filePath.startsWith(context.workingDirectory)) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: `Access denied: ${params.path} is outside working directory`,
            code: &apos;ACCESS_DENIED&apos;,
            recoverable: false,
            suggestion: &apos;Provide a path relative to the working directory&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      }

      // Read file
      const content = await fs.readFile(filePath, encoding);
      const stats = await fs.stat(filePath);

      context.logger.debug(`Read file: ${params.path} (${stats.size} bytes)`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: {
          content,
          size: stats.size,
          lastModified: stats.mtime,
          encoding
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    } catch (error: any) {
      // Handle specific errors
      if (error.code === &apos;ENOENT&apos;) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: `File not found: ${params.path}`,
            code: &apos;FILE_NOT_FOUND&apos;,
            recoverable: false,
            suggestion: &apos;Check the file path and try again&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      } else if (error.code === &apos;EACCES&apos;) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: `Permission denied: ${params.path}`,
            code: &apos;PERMISSION_DENIED&apos;,
            recoverable: false,
            suggestion: &apos;Check file permissions&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      }

      // Unknown error
      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: &apos;UNKNOWN_ERROR&apos;,
          recoverable: true,
          stack: error.stack
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  estimateCost(params: any): number {
    // Cost proportional to file size (if known)
    // For read operations, cost is low
    return 1;
  }
}
</codeblock>
    <section><title>Write File Tool</title></section>
    <codeblock outputclass="language-typescript">export class WriteFileTool implements Tool {
  readonly name = &apos;write_file&apos;;
  readonly description = &apos;Write content to a file (creates or overwrites)&apos;;
  readonly requiresApproval = true; // Destructive operation
  readonly cacheable = false;
  readonly retryable = false; // Don&apos;t retry writes
  readonly dependencies = [&apos;read_file&apos;]; // May need to read before overwriting

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      path: {
        type: &apos;string&apos;,
        description: &apos;Path to the file to write (relative to working directory)&apos;
      },
      content: {
        type: &apos;string&apos;,
        description: &apos;Content to write to the file&apos;
      },
      encoding: {
        type: &apos;string&apos;,
        description: &apos;File encoding (default: utf-8)&apos;,
        enum: [&apos;utf-8&apos;, &apos;ascii&apos;, &apos;base64&apos;]
      },
      createDirectories: {
        type: &apos;boolean&apos;,
        description: &apos;Create parent directories if they don\&apos;t exist (default: true)&apos;
      }
    },
    required: [&apos;path&apos;, &apos;content&apos;]
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const encoding = params.encoding || &apos;utf-8&apos;;
    const createDirs = params.createDirectories !== false;
    const filePath = path.resolve(context.workingDirectory, params.path);

    try {
      // Security: Ensure file is within working directory
      if (!filePath.startsWith(context.workingDirectory)) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: `Access denied: ${params.path} is outside working directory`,
            code: &apos;ACCESS_DENIED&apos;,
            recoverable: false
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      }

      // Create parent directories if needed
      if (createDirs) {
        await fs.mkdir(path.dirname(filePath), { recursive: true });
      }

      // Write file
      await fs.writeFile(filePath, params.content, encoding);
      const stats = await fs.stat(filePath);

      context.logger.info(`Wrote file: ${params.path} (${stats.size} bytes)`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: {
          path: params.path,
          size: stats.size,
          encoding
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date(),
          approvalGranted: true
        }
      };
    } catch (error: any) {
      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: error.code || &apos;UNKNOWN_ERROR&apos;,
          recoverable: false // Don&apos;t retry writes
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  estimateCost(params: any): number {
    // Cost proportional to content size
    return Math.ceil(params.content.length / 1000);
  }
}
</codeblock>
    <section><title>List Files Tool</title></section>
    <codeblock outputclass="language-typescript">export class ListFilesTool implements Tool {
  readonly name = &apos;list_files&apos;;
  readonly description = &apos;List files in a directory&apos;;
  readonly requiresApproval = false;
  readonly cacheable = true;
  readonly retryable = true;

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      path: {
        type: &apos;string&apos;,
        description: &apos;Directory path (default: current directory)&apos;
      },
      recursive: {
        type: &apos;boolean&apos;,
        description: &apos;List files recursively (default: false)&apos;
      },
      pattern: {
        type: &apos;string&apos;,
        description: &apos;Glob pattern to filter files (e.g., &quot;*.ts&quot;)&apos;
      },
      includeHidden: {
        type: &apos;boolean&apos;,
        description: &apos;Include hidden files (default: false)&apos;
      }
    }
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const dirPath = path.resolve(
      context.workingDirectory,
      params.path || &apos;.&apos;
    );

    try {
      const files = await this.listFiles(
        dirPath,
        params.recursive || false,
        params.pattern,
        params.includeHidden || false
      );

      context.logger.debug(`Listed ${files.length} files in ${params.path || &apos;.&apos;}`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: {
          files,
          count: files.length
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    } catch (error: any) {
      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: error.code || &apos;UNKNOWN_ERROR&apos;,
          recoverable: true
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  private async listFiles(
    dir: string,
    recursive: boolean,
    pattern?: string,
    includeHidden?: boolean
  ): Promise&lt;string[]&gt; {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: string[] = [];

    for (const entry of entries) {
      // Skip hidden files if not included
      if (!includeHidden &amp;&amp; entry.name.startsWith(&apos;.&apos;)) {
        continue;
      }

      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        if (recursive) {
          const subFiles = await this.listFiles(
            fullPath,
            recursive,
            pattern,
            includeHidden
          );
          files.push(...subFiles);
        }
      } else if (entry.isFile()) {
        // Apply pattern filter if specified
        if (!pattern || this.matchesPattern(entry.name, pattern)) {
          files.push(fullPath);
        }
      }
    }

    return files;
  }

  private matchesPattern(filename: string, pattern: string): boolean {
    // Simple glob matching (in production, use a library like minimatch)
    const regex = new RegExp(
      pattern
        .replace(/\./g, &apos;\\.&apos;)
        .replace(/\*/g, &apos;.*&apos;)
        .replace(/\?/g, &apos;.&apos;)
    );
    return regex.test(filename);
  }

  estimateCost(params: any): number {
    // Recursive listing is more expensive
    return params.recursive ? 5 : 1;
  }
}
</codeblock>
    <section><title>Git Tools</title></section>
    <section><title>Git Status Tool</title></section>
    <codeblock outputclass="language-typescript">import { exec } from &apos;child_process&apos;;
import { promisify } from &apos;util&apos;;

const execAsync = promisify(exec);

export class GitStatusTool implements Tool {
  readonly name = &apos;git_status&apos;;
  readonly description = &apos;Get git repository status&apos;;
  readonly requiresApproval = false;
  readonly cacheable = true; // Can cache for a few seconds
  readonly retryable = true;

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      path: {
        type: &apos;string&apos;,
        description: &apos;Repository path (default: current directory)&apos;
      },
      includeUntracked: {
        type: &apos;boolean&apos;,
        description: &apos;Include untracked files (default: true)&apos;
      }
    }
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const repoPath = path.resolve(
      context.workingDirectory,
      params.path || &apos;.&apos;
    );

    try {
      // Get git status in porcelain format (machine-readable)
      const { stdout } = await execAsync(&apos;git status --porcelain&apos;, {
        cwd: repoPath
      });

      // Parse status
      const status = this.parseGitStatus(stdout, params.includeUntracked !== false);

      context.logger.debug(`Git status: ${status.modified.length} modified, ${status.staged.length} staged`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: status,
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    } catch (error: any) {
      // Check if this is a git repository
      if (error.message.includes(&apos;not a git repository&apos;)) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: `Not a git repository: ${params.path || &apos;.&apos;}`,
            code: &apos;NOT_A_GIT_REPO&apos;,
            recoverable: false,
            suggestion: &apos;Run git init to initialize a repository&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      }

      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: &apos;GIT_ERROR&apos;,
          recoverable: true
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  private parseGitStatus(output: string, includeUntracked: boolean) {
    const lines = output.split(&apos;\n&apos;).filter(line =&gt; line.trim());

    const status = {
      staged: [] as string[],
      modified: [] as string[],
      untracked: [] as string[],
      deleted: [] as string[],
      clean: lines.length === 0
    };

    for (const line of lines) {
      const statusCode = line.substring(0, 2);
      const file = line.substring(3);

      // First character is staged status
      if (statusCode[0] !== &apos; &apos; &amp;&amp; statusCode[0] !== &apos;?&apos;) {
        status.staged.push(file);
      }

      // Second character is working tree status
      if (statusCode[1] === &apos;M&apos;) {
        status.modified.push(file);
      } else if (statusCode[1] === &apos;D&apos;) {
        status.deleted.push(file);
      } else if (statusCode === &apos;??&apos;) {
        if (includeUntracked) {
          status.untracked.push(file);
        }
      }
    }

    return status;
  }
}
</codeblock>
    <section><title>Git Commit Tool</title></section>
    <codeblock outputclass="language-typescript">export class GitCommitTool implements Tool {
  readonly name = &apos;git_commit&apos;;
  readonly description = &apos;Create a git commit&apos;;
  readonly requiresApproval = true; // Commits require approval
  readonly cacheable = false;
  readonly retryable = false;
  readonly dependencies = [&apos;git_status&apos;]; // Should check status first

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      message: {
        type: &apos;string&apos;,
        description: &apos;Commit message&apos;
      },
      files: {
        type: &apos;array&apos;,
        description: &apos;Files to stage (default: all modified files)&apos;
      },
      path: {
        type: &apos;string&apos;,
        description: &apos;Repository path (default: current directory)&apos;
      }
    },
    required: [&apos;message&apos;]
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const repoPath = path.resolve(
      context.workingDirectory,
      params.path || &apos;.&apos;
    );

    try {
      // Stage files
      if (params.files &amp;&amp; params.files.length &gt; 0) {
        // Stage specific files
        const files = params.files.join(&apos; &apos;);
        await execAsync(`git add ${files}`, { cwd: repoPath });
      } else {
        // Stage all modified files
        await execAsync(&apos;git add -u&apos;, { cwd: repoPath });
      }

      // Create commit
      const { stdout } = await execAsync(
        `git commit -m &quot;${params.message.replace(/&quot;/g, &apos;\\&quot;&apos;)}&quot;`,
        { cwd: repoPath }
      );

      // Extract commit hash
      const match = stdout.match(/\[.+?\s+([a-f0-9]+)\]/);
      const commitHash = match ? match[1] : &apos;unknown&apos;;

      context.logger.info(`Created commit: ${commitHash}`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: {
          commitHash,
          message: params.message,
          output: stdout
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date(),
          approvalGranted: true
        }
      };
    } catch (error: any) {
      // Parse common git commit errors
      if (error.message.includes(&apos;nothing to commit&apos;)) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: &apos;Nothing to commit (working tree clean)&apos;,
            code: &apos;NOTHING_TO_COMMIT&apos;,
            recoverable: false,
            suggestion: &apos;Make changes to files before committing&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      } else if (error.message.includes(&apos;Please tell me who you are&apos;)) {
        return {
          callId: params.callId,
          toolName: this.name,
          success: false,
          error: {
            message: &apos;Git user not configured&apos;,
            code: &apos;GIT_USER_NOT_CONFIGURED&apos;,
            recoverable: true,
            suggestion: &apos;Configure git user: git config user.name &quot;Name&quot; &amp;&amp; git config user.email &quot;email@example.com&quot;&apos;
          },
          metadata: {
            durationMs: Date.now() - startTime,
            cached: false,
            timestamp: new Date()
          }
        };
      }

      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: &apos;GIT_ERROR&apos;,
          recoverable: true
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }
}
</codeblock>
    <section><title>Code Analysis Tools</title></section>
    <section><title>Search Code Tool</title></section>
    <codeblock outputclass="language-typescript">export class SearchCodeTool implements Tool {
  readonly name = &apos;search_code&apos;;
  readonly description = &apos;Search for code patterns using regex&apos;;
  readonly requiresApproval = false;
  readonly cacheable = true;
  readonly retryable = true;
  readonly timeoutMs = 30000; // 30 second timeout

  readonly parameters: ToolParameters = {
    type: &apos;object&apos;,
    properties: {
      pattern: {
        type: &apos;string&apos;,
        description: &apos;Regex pattern to search for&apos;
      },
      path: {
        type: &apos;string&apos;,
        description: &apos;Path to search in (default: current directory)&apos;
      },
      filePattern: {
        type: &apos;string&apos;,
        description: &apos;File pattern to search (e.g., &quot;*.ts&quot;)&apos;
      },
      caseSensitive: {
        type: &apos;boolean&apos;,
        description: &apos;Case sensitive search (default: false)&apos;
      },
      includeContext: {
        type: &apos;boolean&apos;,
        description: &apos;Include surrounding lines (default: false)&apos;
      },
      contextLines: {
        type: &apos;number&apos;,
        description: &apos;Number of context lines before/after match (default: 2)&apos;
      }
    },
    required: [&apos;pattern&apos;]
  };

  async execute(params: any, context: ToolContext): Promise&lt;ToolResult&gt; {
    const startTime = Date.now();
    const searchPath = path.resolve(
      context.workingDirectory,
      params.path || &apos;.&apos;
    );

    try {
      // Build grep command (using ripgrep if available, fallback to grep)
      const useRg = await this.hasRipgrep();
      const results = useRg
        ? await this.searchWithRipgrep(searchPath, params)
        : await this.searchWithGrep(searchPath, params);

      context.logger.debug(`Found ${results.length} matches for pattern: ${params.pattern}`);

      return {
        callId: params.callId,
        toolName: this.name,
        success: true,
        data: {
          matches: results,
          count: results.length
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    } catch (error: any) {
      return {
        callId: params.callId,
        toolName: this.name,
        success: false,
        error: {
          message: error.message,
          code: &apos;SEARCH_ERROR&apos;,
          recoverable: true
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  private async hasRipgrep(): Promise&lt;boolean&gt; {
    try {
      await execAsync(&apos;which rg&apos;);
      return true;
    } catch {
      return false;
    }
  }

  private async searchWithRipgrep(
    searchPath: string,
    params: any
  ): Promise&lt;Array&lt;{ file: string; line: number; content: string; context?: string[] }&gt;&gt; {
    // Build ripgrep command
    let cmd = &apos;rg --json&apos;;

    if (!params.caseSensitive) cmd += &apos; -i&apos;;
    if (params.filePattern) cmd += ` -g &quot;${params.filePattern}&quot;`;
    if (params.includeContext) cmd += ` -C ${params.contextLines || 2}`;

    cmd += ` &quot;${params.pattern}&quot; &quot;${searchPath}&quot;`;

    const { stdout } = await execAsync(cmd);

    // Parse ripgrep JSON output
    const results = [];
    for (const line of stdout.split(&apos;\n&apos;)) {
      if (!line.trim()) continue;

      try {
        const match = JSON.parse(line);
        if (match.type === &apos;match&apos;) {
          results.push({
            file: match.data.path.text,
            line: match.data.line_number,
            content: match.data.lines.text,
            context: match.data.context?.lines?.map((l: any) =&gt; l.text)
          });
        }
      } catch {
        // Skip invalid JSON lines
      }
    }

    return results;
  }

  private async searchWithGrep(
    searchPath: string,
    params: any
  ): Promise&lt;Array&lt;{ file: string; line: number; content: string }&gt;&gt; {
    // Fallback to standard grep
    let cmd = &apos;grep -rn&apos;;

    if (!params.caseSensitive) cmd += &apos; -i&apos;;
    if (params.filePattern) cmd += ` --include=&quot;${params.filePattern}&quot;`;

    cmd += ` &quot;${params.pattern}&quot; &quot;${searchPath}&quot;`;

    const { stdout } = await execAsync(cmd);

    // Parse grep output: file:line:content
    const results = [];
    for (const line of stdout.split(&apos;\n&apos;)) {
      if (!line.trim()) continue;

      const match = line.match(/^(.+?):(\d+):(.+)$/);
      if (match) {
        results.push({
          file: match[1],
          line: parseInt(match[2], 10),
          content: match[3]
        });
      }
    }

    return results;
  }

  estimateCost(params: any): number {
    // Recursive search is expensive
    return 10;
  }
}
</codeblock>
    <section><title>4.4 Tool Registry</title></section>
    <p>The tool registry is the central catalog of all available tools. It provides:
- Tool registration and discovery
- Validation that all dependencies exist
- Tool lookup by name
- Metadata about available tools for AI context</p>
    <section><title>Tool Registry Implementation</title></section>
    <codeblock outputclass="language-typescript">/**
 * Central registry of all available tools
 */
export class ToolRegistry {
  private tools = new Map&lt;string, Tool&gt;();
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Register a tool
   */
  register(tool: Tool): void {
    // Validate tool
    if (!tool.name) {
      throw new Error(&apos;Tool must have a name&apos;);
    }

    if (!tool.description) {
      throw new Error(`Tool ${tool.name} must have a description`);
    }

    if (!tool.parameters) {
      throw new Error(`Tool ${tool.name} must define parameters`);
    }

    // Check for name conflicts
    if (this.tools.has(tool.name)) {
      throw new Error(`Tool ${tool.name} is already registered`);
    }

    // Validate dependencies exist (will check later after all tools registered)
    this.tools.set(tool.name, tool);
    this.logger.debug(`Registered tool: ${tool.name}`);
  }

  /**
   * Register multiple tools
   */
  registerAll(tools: Tool[]): void {
    for (const tool of tools) {
      this.register(tool);
    }

    // Validate all dependencies exist
    this.validateDependencies();
  }

  /**
   * Get a tool by name
   */
  get(name: string): Tool {
    const tool = this.tools.get(name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return tool;
  }

  /**
   * Check if a tool exists
   */
  has(name: string): boolean {
    return this.tools.has(name);
  }

  /**
   * Get all tool names
   */
  getToolNames(): string[] {
    return Array.from(this.tools.keys());
  }

  /**
   * Get tool metadata for AI context
   * Returns tool definitions in the format AI models expect
   */
  getToolsForAI(): Array&lt;{
    name: string;
    description: string;
    parameters: ToolParameters;
  }&gt; {
    return Array.from(this.tools.values()).map(tool =&gt; ({
      name: tool.name,
      description: tool.description,
      parameters: tool.parameters
    }));
  }

  /**
   * Validate that all tool dependencies exist
   */
  private validateDependencies(): void {
    for (const [name, tool] of this.tools) {
      if (!tool.dependencies) continue;

      for (const dep of tool.dependencies) {
        if (!this.tools.has(dep)) {
          throw new Error(
            `Tool ${name} depends on ${dep}, but ${dep} is not registered`
          );
        }
      }
    }
  }

  /**
   * Get dependency graph for a tool
   * Returns all tools this tool depends on (recursively)
   */
  getDependencies(toolName: string): string[] {
    const tool = this.get(toolName);
    if (!tool.dependencies || tool.dependencies.length === 0) {
      return [];
    }

    const allDeps = new Set&lt;string&gt;();
    const visited = new Set&lt;string&gt;();

    const visit = (name: string) =&gt; {
      if (visited.has(name)) return;
      visited.add(name);

      const t = this.get(name);
      if (!t.dependencies) return;

      for (const dep of t.dependencies) {
        allDeps.add(dep);
        visit(dep);
      }
    };

    visit(toolName);
    return Array.from(allDeps);
  }

  /**
   * Get statistics about registered tools
   */
  getStats(): {
    totalTools: number;
    byCategory: Record&lt;string, number&gt;;
    requireApproval: number;
    cacheable: number;
  } {
    const stats = {
      totalTools: this.tools.size,
      byCategory: {} as Record&lt;string, number&gt;,
      requireApproval: 0,
      cacheable: 0
    };

    for (const tool of this.tools.values()) {
      // Count approval requirements
      if (tool.requiresApproval) {
        stats.requireApproval++;
      }

      // Count cacheable tools
      if (tool.cacheable) {
        stats.cacheable++;
      }

      // Categorize by type (inferred from name)
      const category = this.inferCategory(tool.name);
      stats.byCategory[category] = (stats.byCategory[category] || 0) + 1;
    }

    return stats;
  }

  private inferCategory(toolName: string): string {
    if (toolName.startsWith(&apos;git_&apos;)) return &apos;Git&apos;;
    if (toolName.includes(&apos;file&apos;)) return &apos;File System&apos;;
    if (toolName.includes(&apos;search&apos;) || toolName.includes(&apos;analyze&apos;)) return &apos;Code Analysis&apos;;
    if (toolName.includes(&apos;github&apos;) || toolName.includes(&apos;api&apos;)) return &apos;External&apos;;
    return &apos;Other&apos;;
  }
}
</codeblock>
    <section><title>Bootstrap Tool Registry</title></section>
    <codeblock outputclass="language-typescript">/**
 * Bootstrap the tool registry with all available tools
 */
export function createToolRegistry(logger: Logger): ToolRegistry {
  const registry = new ToolRegistry(logger);

  // Register file system tools
  registry.register(new ReadFileTool());
  registry.register(new WriteFileTool());
  registry.register(new ListFilesTool());

  // Register git tools
  registry.register(new GitStatusTool());
  registry.register(new GitCommitTool());

  // Register code analysis tools
  registry.register(new SearchCodeTool());

  // Log statistics
  const stats = registry.getStats();
  logger.info(`Tool registry initialized: ${stats.totalTools} tools registered`);
  logger.debug(`Categories: ${JSON.stringify(stats.byCategory)}`);
  logger.debug(`Require approval: ${stats.requireApproval}, Cacheable: ${stats.cacheable}`);

  return registry;
}
</codeblock>
    <section><title>Usage Example</title></section>
    <codeblock outputclass="language-typescript">// Bootstrap registry
const logger = new Logger();
const registry = createToolRegistry(logger);

// Get tool metadata for AI
const tools = registry.getToolsForAI();
const aiResponse = await provider.chat({
  messages: [{ role: &apos;user&apos;, content: &apos;List all files in src/&apos; }],
  tools // AI can now see all available tools
});

// AI returns: Use tool &quot;list_files&quot; with params { path: &quot;src/&quot; }

// Execute the tool
const tool = registry.get(&apos;list_files&apos;);
const result = await tool.execute(
  { path: &apos;src/&apos; },
  { workingDirectory: &apos;/project&apos;, logger, toolRegistry: registry }
);

console.log(result.data.files);
</codeblock>
    <section><title>4.5 Dependency Resolution</title></section>
    <p>Tools can depend on other tools. For example, <codeph>edit_file</codeph> might depend on <codeph>read_file</codeph> and <codeph>write_file</codeph>. The dependency resolver builds an execution graph and determines the optimal execution order.</p>
    <section><title>Dependency Graph</title></section>
    <codeblock outputclass="language-typescript">/**
 * Represents a directed acyclic graph (DAG) of tool dependencies
 */
export class DependencyGraph {
  private nodes = new Map&lt;string, DependencyNode&gt;();

  /**
   * Add a node to the graph
   */
  addNode(callId: string, toolName: string, dependencies: string[] = []): void {
    const node: DependencyNode = {
      callId,
      toolName,
      dependencies,
      dependents: []
    };

    this.nodes.set(callId, node);

    // Update dependents
    for (const depId of dependencies) {
      const depNode = this.nodes.get(depId);
      if (depNode) {
        depNode.dependents.push(callId);
      }
    }
  }

  /**
   * Get a node by call ID
   */
  getNode(callId: string): DependencyNode | undefined {
    return this.nodes.get(callId);
  }

  /**
   * Get all nodes
   */
  getAllNodes(): DependencyNode[] {
    return Array.from(this.nodes.values());
  }

  /**
   * Detect circular dependencies
   * Returns the cycle path if found, null otherwise
   */
  detectCycle(): string[] | null {
    const visited = new Set&lt;string&gt;();
    const recursionStack = new Set&lt;string&gt;();
    const path: string[] = [];

    const hasCycle = (callId: string): boolean =&gt; {
      visited.add(callId);
      recursionStack.add(callId);
      path.push(callId);

      const node = this.nodes.get(callId);
      if (!node) return false;

      for (const dep of node.dependencies) {
        if (!visited.has(dep)) {
          if (hasCycle(dep)) return true;
        } else if (recursionStack.has(dep)) {
          // Found cycle
          path.push(dep);
          return true;
        }
      }

      recursionStack.delete(callId);
      path.pop();
      return false;
    };

    for (const callId of this.nodes.keys()) {
      if (!visited.has(callId)) {
        if (hasCycle(callId)) {
          return path;
        }
      }
    }

    return null;
  }

  /**
   * Topological sort - returns execution order
   * Throws error if cycle detected
   */
  topologicalSort(): string[] {
    // Detect cycles first
    const cycle = this.detectCycle();
    if (cycle) {
      throw new Error(
        `Circular dependency detected: ${cycle.join(&apos; -&gt; &apos;)}`
      );
    }

    const sorted: string[] = [];
    const visited = new Set&lt;string&gt;();

    const visit = (callId: string) =&gt; {
      if (visited.has(callId)) return;
      visited.add(callId);

      const node = this.nodes.get(callId);
      if (!node) return;

      // Visit dependencies first (depth-first)
      for (const dep of node.dependencies) {
        visit(dep);
      }

      sorted.push(callId);
    };

    // Visit all nodes
    for (const callId of this.nodes.keys()) {
      visit(callId);
    }

    return sorted;
  }

  /**
   * Get execution levels for parallel execution
   * Returns groups of calls that can execute in parallel
   */
  getExecutionLevels(): string[][] {
    const sorted = this.topologicalSort();
    const levels: string[][] = [];
    const nodeLevel = new Map&lt;string, number&gt;();

    // Calculate level for each node
    for (const callId of sorted) {
      const node = this.nodes.get(callId)!;

      // Node&apos;s level is max(dependency levels) + 1
      let level = 0;
      for (const dep of node.dependencies) {
        const depLevel = nodeLevel.get(dep) || 0;
        level = Math.max(level, depLevel + 1);
      }

      nodeLevel.set(callId, level);

      // Add to level group
      if (!levels[level]) {
        levels[level] = [];
      }
      levels[level].push(callId);
    }

    return levels;
  }

  /**
   * Get calls that have no dependencies (can execute immediately)
   */
  getRootNodes(): string[] {
    return this.getAllNodes()
      .filter(node =&gt; node.dependencies.length === 0)
      .map(node =&gt; node.callId);
  }

  /**
   * Get calls that depend on a specific call
   */
  getDependents(callId: string): string[] {
    const node = this.nodes.get(callId);
    return node ? node.dependents : [];
  }
}

interface DependencyNode {
  callId: string;
  toolName: string;
  dependencies: string[];
  dependents: string[];
}
</codeblock>
    <section><title>Dependency Resolver</title></section>
    <codeblock outputclass="language-typescript">/**
 * Resolves tool call dependencies and plans execution
 */
export class DependencyResolver {
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Build dependency graph from tool calls
   */
  buildGraph(toolCalls: ToolCall[], registry: ToolRegistry): DependencyGraph {
    const graph = new DependencyGraph();

    for (const call of toolCalls) {
      // Get tool definition
      const tool = registry.get(call.toolName);

      // Collect dependencies
      const dependencies = call.dependsOn || [];

      // Add tool&apos;s declared dependencies (if any)
      if (tool.dependencies) {
        // Find calls that provide these dependencies
        for (const depToolName of tool.dependencies) {
          const depCall = toolCalls.find(c =&gt; c.toolName === depToolName);
          if (depCall &amp;&amp; !dependencies.includes(depCall.id)) {
            dependencies.push(depCall.id);
          }
        }
      }

      graph.addNode(call.id, call.toolName, dependencies);
    }

    // Validate no cycles
    const cycle = graph.detectCycle();
    if (cycle) {
      this.logger.error(`Circular dependency: ${cycle.join(&apos; -&gt; &apos;)}`);
      throw new Error(`Circular dependency detected: ${cycle.join(&apos; -&gt; &apos;)}`);
    }

    return graph;
  }

  /**
   * Plan execution order
   */
  planExecution(graph: DependencyGraph): ExecutionPlan {
    const sequential = graph.topologicalSort();
    const parallel = graph.getExecutionLevels();

    this.logger.debug(`Execution plan:`);
    this.logger.debug(`  Sequential: ${sequential.length} calls`);
    this.logger.debug(`  Parallel: ${parallel.length} levels`);

    return {
      sequential,
      parallel,
      totalCalls: sequential.length,
      maxParallelism: Math.max(...parallel.map(level =&gt; level.length))
    };
  }
}

interface ExecutionPlan {
  // Sequential execution order (dependencies first)
  sequential: string[];

  // Parallel execution levels (can run concurrently within each level)
  parallel: string[][];

  // Total number of calls
  totalCalls: number;

  // Maximum parallelism (largest level size)
  maxParallelism: number;
}
</codeblock>
    <section><title>Example: Dependency Resolution</title></section>
    <codeblock outputclass="language-typescript">const toolCalls: ToolCall[] = [
  {
    id: &apos;call_1&apos;,
    toolName: &apos;list_files&apos;,
    parameters: { path: &apos;src/&apos; }
  },
  {
    id: &apos;call_2&apos;,
    toolName: &apos;read_file&apos;,
    parameters: { path: &apos;src/index.ts&apos; },
    dependsOn: [&apos;call_1&apos;] // Depends on listing files first
  },
  {
    id: &apos;call_3&apos;,
    toolName: &apos;read_file&apos;,
    parameters: { path: &apos;src/utils.ts&apos; },
    dependsOn: [&apos;call_1&apos;]
  },
  {
    id: &apos;call_4&apos;,
    toolName: &apos;search_code&apos;,
    parameters: { pattern: &apos;TODO&apos;, path: &apos;src/&apos; }
    // No dependencies - can run in parallel with call_1
  },
  {
    id: &apos;call_5&apos;,
    toolName: &apos;write_file&apos;,
    parameters: { path: &apos;summary.md&apos;, content: &apos;...&apos; },
    dependsOn: [&apos;call_2&apos;, &apos;call_3&apos;, &apos;call_4&apos;] // Depends on all analysis
  }
];

const resolver = new DependencyResolver(logger);
const graph = resolver.buildGraph(toolCalls, registry);
const plan = resolver.planExecution(graph);

console.log(&apos;Sequential:&apos;, plan.sequential);
// [&apos;call_1&apos;, &apos;call_4&apos;, &apos;call_2&apos;, &apos;call_3&apos;, &apos;call_5&apos;]

console.log(&apos;Parallel levels:&apos;, plan.parallel);
// [
//   [&apos;call_1&apos;, &apos;call_4&apos;],     // Level 0: Can run in parallel
//   [&apos;call_2&apos;, &apos;call_3&apos;],     // Level 1: Wait for call_1
//   [&apos;call_5&apos;]                // Level 2: Wait for call_2, call_3, call_4
// ]

console.log(&apos;Max parallelism:&apos;, plan.maxParallelism);
// 2 (level 0 and level 1 both have 2 calls)
</codeblock>
    <section><title>4.6 Parallel Execution</title></section>
    <p>Now that we can resolve dependencies, let&apos;s implement parallel execution to maximize performance.</p>
    <section><title>Parallel Executor</title></section>
    <codeblock outputclass="language-typescript">/**
 * Executes tool calls in parallel when possible
 */
export class ParallelExecutor {
  private logger: Logger;
  private maxConcurrency: number;

  constructor(logger: Logger, maxConcurrency: number = 5) {
    this.logger = logger;
    this.maxConcurrency = maxConcurrency;
  }

  /**
   * Execute tool calls according to execution plan
   */
  async execute(
    toolCalls: ToolCall[],
    plan: ExecutionPlan,
    executor: (call: ToolCall) =&gt; Promise&lt;ToolResult&gt;,
    options: ExecutionOptions = {}
  ): Promise&lt;Map&lt;string, ToolResult&gt;&gt; {
    const results = new Map&lt;string, ToolResult&gt;();
    const startTime = Date.now();

    if (options.parallelExecution &amp;&amp; plan.parallel.length &gt; 0) {
      // Execute level by level
      for (let i = 0; i &lt; plan.parallel.length; i++) {
        const level = plan.parallel[i];
        this.logger.debug(`Executing level ${i}: ${level.length} calls`);

        // Execute all calls in this level in parallel
        const levelResults = await this.executeLevel(
          level,
          toolCalls,
          executor,
          results,
          options
        );

        // Merge results
        for (const [callId, result] of levelResults) {
          results.set(callId, result);
        }

        // Check for errors
        const errors = Array.from(levelResults.values()).filter(r =&gt; !r.success);
        if (errors.length &gt; 0 &amp;&amp; options.failFast) {
          this.logger.error(`Level ${i} failed with ${errors.length} errors, stopping`);
          throw new Error(`Execution failed at level ${i}`);
        }
      }
    } else {
      // Sequential execution
      this.logger.debug(`Executing sequentially: ${plan.sequential.length} calls`);

      for (const callId of plan.sequential) {
        const call = toolCalls.find(c =&gt; c.id === callId);
        if (!call) continue;

        try {
          const result = await executor(call);
          results.set(callId, result);

          if (!result.success &amp;&amp; options.failFast) {
            throw new Error(`Call ${callId} failed: ${result.error?.message}`);
          }
        } catch (error: any) {
          this.logger.error(`Call ${callId} threw error: ${error.message}`);
          if (options.failFast) throw error;
        }
      }
    }

    const totalTime = Date.now() - startTime;
    this.logger.info(`Executed ${results.size} calls in ${totalTime}ms`);

    return results;
  }

  /**
   * Execute a single level (all calls in parallel)
   */
  private async executeLevel(
    level: string[],
    allCalls: ToolCall[],
    executor: (call: ToolCall) =&gt; Promise&lt;ToolResult&gt;,
    previousResults: Map&lt;string, ToolResult&gt;,
    options: ExecutionOptions
  ): Promise&lt;Map&lt;string, ToolResult&gt;&gt; {
    const results = new Map&lt;string, ToolResult&gt;();

    // Limit concurrency
    const batches = this.createBatches(level, this.maxConcurrency);

    for (const batch of batches) {
      // Execute batch in parallel
      const promises = batch.map(async (callId) =&gt; {
        const call = allCalls.find(c =&gt; c.id === callId);
        if (!call) return;

        try {
          // Resolve parameter references from previous results
          const resolvedCall = this.resolveParameters(call, previousResults);

          const result = await executor(resolvedCall);
          results.set(callId, result);
        } catch (error: any) {
          this.logger.error(`Call ${callId} failed: ${error.message}`);
          results.set(callId, {
            callId,
            toolName: call.toolName,
            success: false,
            error: {
              message: error.message,
              code: &apos;EXECUTION_ERROR&apos;,
              recoverable: false
            },
            metadata: {
              durationMs: 0,
              cached: false,
              timestamp: new Date()
            }
          });
        }
      });

      await Promise.all(promises);
    }

    return results;
  }

  /**
   * Create batches for concurrency limiting
   */
  private createBatches&lt;T&gt;(items: T[], batchSize: number): T[][] {
    const batches: T[][] = [];
    for (let i = 0; i &lt; items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * Resolve parameter references from previous results
   * Example: ${call_1.data.files[0]} → &quot;src/index.ts&quot;
   */
  private resolveParameters(
    call: ToolCall,
    results: Map&lt;string, ToolResult&gt;
  ): ToolCall {
    const params = { ...call.parameters };

    // Simple template resolution (in production, use a proper template engine)
    const resolveValue = (value: any): any =&gt; {
      if (typeof value === &apos;string&apos; &amp;&amp; value.includes(&apos;${&apos;)) {
        // Extract reference: ${call_1.data.files}
        const match = value.match(/\$\{(.+?)\}/);
        if (match) {
          const ref = match[1];
          const [callId, ...path] = ref.split(&apos;.&apos;);

          const result = results.get(callId);
          if (!result || !result.success) {
            throw new Error(`Cannot resolve ${ref}: call ${callId} failed or not found`);
          }

          // Navigate path: data.files[0]
          let resolved: any = result;
          for (const segment of path) {
            if (segment.includes(&apos;[&apos;)) {
              // Array index
              const [prop, index] = segment.split(&apos;[&apos;);
              resolved = resolved[prop][parseInt(index.replace(&apos;]&apos;, &apos;&apos;), 10)];
            } else {
              resolved = resolved[segment];
            }
          }

          return resolved;
        }
      } else if (typeof value === &apos;object&apos; &amp;&amp; value !== null) {
        // Recursively resolve objects and arrays
        if (Array.isArray(value)) {
          return value.map(resolveValue);
        } else {
          const resolved: any = {};
          for (const [k, v] of Object.entries(value)) {
            resolved[k] = resolveValue(v);
          }
          return resolved;
        }
      }

      return value;
    };

    for (const [key, value] of Object.entries(params)) {
      params[key] = resolveValue(value);
    }

    return { ...call, parameters: params };
  }
}

interface ExecutionOptions {
  // Execute in parallel when possible
  parallelExecution?: boolean;

  // Stop on first error
  failFast?: boolean;

  // Timeout for entire execution
  timeoutMs?: number;
}
</codeblock>
    <section><title>Performance Comparison</title></section>
    <codeblock outputclass="language-typescript">// Example: Sequential vs Parallel

const toolCalls: ToolCall[] = [
  { id: &apos;1&apos;, toolName: &apos;read_file&apos;, parameters: { path: &apos;a.ts&apos; } },
  { id: &apos;2&apos;, toolName: &apos;read_file&apos;, parameters: { path: &apos;b.ts&apos; } },
  { id: &apos;3&apos;, toolName: &apos;read_file&apos;, parameters: { path: &apos;c.ts&apos; } },
  { id: &apos;4&apos;, toolName: &apos;read_file&apos;, parameters: { path: &apos;d.ts&apos; } }
];

// Sequential: 4 * 100ms = 400ms
const sequential = await executeSequentially(toolCalls);

// Parallel: max(100ms, 100ms, 100ms, 100ms) = 100ms
const parallel = await executeInParallel(toolCalls);

// Speedup: 4x faster!
</codeblock>
    <section><title>4.7 Result Caching</title></section>
    <p>Many tools are deterministic - given the same inputs, they produce the same outputs. Result caching avoids redundant work by storing and reusing tool results.</p>
    <section><title>Cache Key Generation</title></section>
    <codeblock outputclass="language-typescript">/**
 * Generate a cache key for a tool call
 */
export class CacheKeyGenerator {
  /**
   * Generate cache key from tool call
   */
  static generateKey(call: ToolCall): string {
    // Key format: toolName:hash(parameters)
    const paramHash = this.hashParameters(call.parameters);
    return `${call.toolName}:${paramHash}`;
  }

  /**
   * Hash parameters for cache key
   */
  private static hashParameters(params: any): string {
    // Stable JSON serialization (sorted keys)
    const normalized = this.normalizeObject(params);
    const json = JSON.stringify(normalized);

    // Simple hash (in production, use a proper hash function like SHA-256)
    return this.simpleHash(json);
  }

  /**
   * Normalize object for stable hashing
   * Sorts keys recursively
   */
  private static normalizeObject(obj: any): any {
    if (obj === null || obj === undefined) {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map(item =&gt; this.normalizeObject(item));
    }

    if (typeof obj === &apos;object&apos;) {
      const sorted: any = {};
      const keys = Object.keys(obj).sort();
      for (const key of keys) {
        sorted[key] = this.normalizeObject(obj[key]);
      }
      return sorted;
    }

    return obj;
  }

  /**
   * Simple hash function (for demonstration)
   * In production, use crypto.createHash(&apos;sha256&apos;)
   */
  private static simpleHash(str: string): string {
    let hash = 0;
    for (let i = 0; i &lt; str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash &lt;&lt; 5) - hash) + char;
      hash = hash &amp; hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16);
  }
}
</codeblock>
    <section><title>Result Cache</title></section>
    <codeblock outputclass="language-typescript">/**
 * Cache for tool results
 */
export class ResultCache {
  private cache = new Map&lt;string, CacheEntry&gt;();
  private logger: Logger;
  private maxSize: number;
  private ttlMs: number;

  constructor(logger: Logger, options: CacheOptions = {}) {
    this.logger = logger;
    this.maxSize = options.maxSize || 1000;
    this.ttlMs = options.ttlMs || 5 * 60 * 1000; // 5 minutes default
  }

  /**
   * Get cached result
   */
  get(key: string): ToolResult | null {
    const entry = this.cache.get(key);

    if (!entry) {
      return null;
    }

    // Check if expired
    const age = Date.now() - entry.timestamp;
    if (age &gt; this.ttlMs) {
      this.cache.delete(key);
      this.logger.debug(`Cache expired: ${key}`);
      return null;
    }

    this.logger.debug(`Cache hit: ${key}`);

    // Mark result as cached
    return {
      ...entry.result,
      metadata: {
        ...entry.result.metadata,
        cached: true
      }
    };
  }

  /**
   * Store result in cache
   */
  set(key: string, result: ToolResult): void {
    // Check cache size limit
    if (this.cache.size &gt;= this.maxSize) {
      this.evictOldest();
    }

    this.cache.set(key, {
      result,
      timestamp: Date.now()
    });

    this.logger.debug(`Cached result: ${key}`);
  }

  /**
   * Check if result is cached
   */
  has(key: string): boolean {
    const entry = this.cache.get(key);
    if (!entry) return false;

    // Check expiration
    const age = Date.now() - entry.timestamp;
    if (age &gt; this.ttlMs) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  /**
   * Clear all cached results
   */
  clear(): void {
    this.cache.clear();
    this.logger.debug(&apos;Cache cleared&apos;);
  }

  /**
   * Clear expired entries
   */
  clearExpired(): void {
    const now = Date.now();
    let cleared = 0;

    for (const [key, entry] of this.cache.entries()) {
      const age = now - entry.timestamp;
      if (age &gt; this.ttlMs) {
        this.cache.delete(key);
        cleared++;
      }
    }

    if (cleared &gt; 0) {
      this.logger.debug(`Cleared ${cleared} expired cache entries`);
    }
  }

  /**
   * Evict oldest entry
   */
  private evictOldest(): void {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.timestamp &lt; oldestTime) {
        oldestTime = entry.timestamp;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
      this.logger.debug(`Evicted oldest cache entry: ${oldestKey}`);
    }
  }

  /**
   * Get cache statistics
   */
  getStats(): CacheStats {
    const now = Date.now();
    let expired = 0;

    for (const entry of this.cache.values()) {
      const age = now - entry.timestamp;
      if (age &gt; this.ttlMs) {
        expired++;
      }
    }

    return {
      size: this.cache.size,
      maxSize: this.maxSize,
      expired,
      hitRate: 0 // Would need to track hits/misses
    };
  }
}

interface CacheEntry {
  result: ToolResult;
  timestamp: number;
}

interface CacheOptions {
  maxSize?: number;
  ttlMs?: number;
}

interface CacheStats {
  size: number;
  maxSize: number;
  expired: number;
  hitRate: number;
}
</codeblock>
    <section><title>Cache Integration Example</title></section>
    <codeblock outputclass="language-typescript">// Using cache with tool execution

const cache = new ResultCache(logger);
const keyGen = new CacheKeyGenerator();

async function executeToolWithCache(
  call: ToolCall,
  tool: Tool
): Promise&lt;ToolResult&gt; {
  // Check if tool is cacheable
  if (!tool.cacheable) {
    return await tool.execute(call.parameters, context);
  }

  // Generate cache key
  const cacheKey = keyGen.generateKey(call);

  // Check cache
  const cached = cache.get(cacheKey);
  if (cached) {
    logger.debug(`Using cached result for ${call.toolName}`);
    return cached;
  }

  // Execute tool
  const result = await tool.execute(call.parameters, context);

  // Cache successful results only
  if (result.success) {
    cache.set(cacheKey, result);
  }

  return result;
}
</codeblock>
    <section><title>Cache Performance Impact</title></section>
    <codeblock outputclass="language-typescript">// Example: Impact of caching on repeated calls

const call = {
  id: &apos;call_1&apos;,
  toolName: &apos;search_code&apos;,
  parameters: { pattern: &apos;TODO&apos;, path: &apos;src/&apos; }
};

// First call: Cache miss, actual execution (500ms)
const result1 = await executeToolWithCache(call, searchTool);
console.log(`Duration: ${result1.metadata.durationMs}ms, Cached: ${result1.metadata.cached}`);
// Duration: 500ms, Cached: false

// Second call: Cache hit, instant (0ms)
const result2 = await executeToolWithCache(call, searchTool);
console.log(`Duration: ${result2.metadata.durationMs}ms, Cached: ${result2.metadata.cached}`);
// Duration: 0ms, Cached: true

// Performance improvement: 500ms → 0ms (100% faster)
</codeblock>
    <section><title>4.8 Tool Orchestrator</title></section>
    <p>Now we bring it all together. The Tool Orchestrator is the main component that coordinates tool execution.</p>
    <section><title>Tool Orchestrator Implementation</title></section>
    <codeblock outputclass="language-typescript">/**
 * Orchestrates tool execution with dependency resolution,
 * parallel execution, caching, and approval workflows
 */
export class ToolOrchestrator {
  private registry: ToolRegistry;
  private cache: ResultCache;
  private resolver: DependencyResolver;
  private executor: ParallelExecutor;
  private logger: Logger;
  private context: ToolContext;

  constructor(
    registry: ToolRegistry,
    logger: Logger,
    workingDirectory: string,
    options: OrchestratorOptions = {}
  ) {
    this.registry = registry;
    this.logger = logger;
    this.cache = new ResultCache(logger, options.cache);
    this.resolver = new DependencyResolver(logger);
    this.executor = new ParallelExecutor(logger, options.maxConcurrency || 5);

    this.context = {
      workingDirectory,
      logger,
      toolRegistry: registry,
      preferences: options.preferences || {},
      cancellationToken: options.cancellationToken
    };
  }

  /**
   * Execute tool calls
   */
  async execute(
    toolCalls: ToolCall[],
    options: ExecutionOptions = {}
  ): Promise&lt;ToolExecutionResult&gt; {
    const startTime = Date.now();

    try {
      this.logger.info(`Executing ${toolCalls.length} tool calls`);

      // 1. Build dependency graph
      const graph = this.resolver.buildGraph(toolCalls, this.registry);

      // 2. Plan execution
      const plan = this.resolver.planExecution(graph);
      this.logger.debug(`Execution plan: ${plan.totalCalls} calls, ${plan.parallel.length} levels`);

      // 3. Execute with caching and approval
      const results = await this.executor.execute(
        toolCalls,
        plan,
        async (call) =&gt; this.executeToolCall(call, options),
        options
      );

      // 4. Aggregate results
      const successCount = Array.from(results.values()).filter(r =&gt; r.success).length;
      const failureCount = results.size - successCount;

      this.logger.info(`Execution complete: ${successCount} successful, ${failureCount} failed`);

      return {
        success: failureCount === 0,
        results: Array.from(results.values()),
        metadata: {
          totalCalls: toolCalls.length,
          successCount,
          failureCount,
          durationMs: Date.now() - startTime,
          cacheHits: this.countCacheHits(results),
          parallelLevels: plan.parallel.length
        }
      };
    } catch (error: any) {
      this.logger.error(`Execution failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * Execute a single tool call with caching and approval
   */
  private async executeToolCall(
    call: ToolCall,
    options: ExecutionOptions
  ): Promise&lt;ToolResult&gt; {
    const tool = this.registry.get(call.toolName);

    // 1. Check cache (if tool is cacheable)
    if (tool.cacheable &amp;&amp; options.enableCache !== false) {
      const cacheKey = CacheKeyGenerator.generateKey(call);
      const cached = this.cache.get(cacheKey);

      if (cached) {
        return cached;
      }
    }

    // 2. Request approval (if required)
    if (tool.requiresApproval &amp;&amp; options.approvalCallback) {
      const approved = await options.approvalCallback(call, tool);

      if (!approved) {
        return {
          callId: call.id,
          toolName: call.toolName,
          success: false,
          error: {
            message: &apos;User denied approval&apos;,
            code: &apos;APPROVAL_DENIED&apos;,
            recoverable: false
          },
          metadata: {
            durationMs: 0,
            cached: false,
            timestamp: new Date(),
            approvalGranted: false
          }
        };
      }
    }

    // 3. Execute tool
    const startTime = Date.now();

    try {
      // Set timeout if specified
      const timeout = tool.timeoutMs || options.timeoutMs;
      const result = timeout
        ? await this.executeWithTimeout(tool, call, timeout)
        : await tool.execute(call.parameters, this.context);

      // Add call ID and duration
      result.callId = call.id;
      result.toolName = call.toolName;
      result.metadata.durationMs = Date.now() - startTime;

      // 4. Cache successful results
      if (result.success &amp;&amp; tool.cacheable &amp;&amp; options.enableCache !== false) {
        const cacheKey = CacheKeyGenerator.generateKey(call);
        this.cache.set(cacheKey, result);
      }

      return result;
    } catch (error: any) {
      this.logger.error(`Tool ${call.toolName} threw error: ${error.message}`);

      return {
        callId: call.id,
        toolName: call.toolName,
        success: false,
        error: {
          message: error.message,
          code: &apos;EXECUTION_ERROR&apos;,
          recoverable: tool.retryable || false,
          stack: error.stack
        },
        metadata: {
          durationMs: Date.now() - startTime,
          cached: false,
          timestamp: new Date()
        }
      };
    }
  }

  /**
   * Execute tool with timeout
   */
  private async executeWithTimeout(
    tool: Tool,
    call: ToolCall,
    timeoutMs: number
  ): Promise&lt;ToolResult&gt; {
    return Promise.race([
      tool.execute(call.parameters, this.context),
      new Promise&lt;ToolResult&gt;((_, reject) =&gt; {
        setTimeout(() =&gt; {
          reject(new Error(`Tool ${call.toolName} timed out after ${timeoutMs}ms`));
        }, timeoutMs);
      })
    ]);
  }

  /**
   * Count cache hits in results
   */
  private countCacheHits(results: Map&lt;string, ToolResult&gt;): number {
    return Array.from(results.values()).filter(r =&gt; r.metadata.cached).length;
  }

  /**
   * Clear result cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Get cache statistics
   */
  getCacheStats(): CacheStats {
    return this.cache.getStats();
  }
}

interface OrchestratorOptions {
  cache?: CacheOptions;
  maxConcurrency?: number;
  preferences?: UserPreferences;
  cancellationToken?: CancellationToken;
}

interface UserPreferences {
  autoApprove?: boolean;
  verbose?: boolean;
  [key: string]: any;
}

interface CancellationToken {
  isCancelled: boolean;
  cancel(): void;
}

interface ToolExecutionResult {
  success: boolean;
  results: ToolResult[];
  metadata: {
    totalCalls: number;
    successCount: number;
    failureCount: number;
    durationMs: number;
    cacheHits: number;
    parallelLevels: number;
  };
}
</codeblock>
    <section><title>Complete Usage Example</title></section>
    <codeblock outputclass="language-typescript">// Bootstrap the orchestrator
const logger = new Logger();
const registry = createToolRegistry(logger);
const orchestrator = new ToolOrchestrator(registry, logger, &apos;/project&apos;, {
  maxConcurrency: 5,
  cache: {
    maxSize: 1000,
    ttlMs: 5 * 60 * 1000 // 5 minutes
  }
});

// Define tool calls
const toolCalls: ToolCall[] = [
  {
    id: &apos;call_1&apos;,
    toolName: &apos;list_files&apos;,
    parameters: { path: &apos;src/&apos;, recursive: true, pattern: &apos;*.ts&apos; }
  },
  {
    id: &apos;call_2&apos;,
    toolName: &apos;search_code&apos;,
    parameters: { pattern: &apos;TODO:&apos;, path: &apos;src/&apos; }
  },
  {
    id: &apos;call_3&apos;,
    toolName: &apos;read_file&apos;,
    parameters: { path: &apos;${call_1.data.files[0]}&apos; },
    dependsOn: [&apos;call_1&apos;]
  },
  {
    id: &apos;call_4&apos;,
    toolName: &apos;write_file&apos;,
    parameters: {
      path: &apos;analysis.md&apos;,
      content: &apos;Analysis results:\n${call_2.data.matches}&apos;
    },
    dependsOn: [&apos;call_2&apos;]
  }
];

// Execute with options
const result = await orchestrator.execute(toolCalls, {
  parallelExecution: true,
  enableCache: true,
  failFast: false,
  approvalCallback: async (call, tool) =&gt; {
    // Show user what will be done
    console.log(`\nTool: ${tool.name}`);
    console.log(`Description: ${tool.description}`);
    console.log(`Parameters: ${JSON.stringify(call.parameters, null, 2)}`);

    // Prompt for approval
    const answer = await promptUser(&apos;Approve? (y/n): &apos;);
    return answer.toLowerCase() === &apos;y&apos;;
  }
});

// Display results
console.log(`\n✓ Execution complete`);
console.log(`  Success: ${result.metadata.successCount}/${result.metadata.totalCalls}`);
console.log(`  Duration: ${result.metadata.durationMs}ms`);
console.log(`  Cache hits: ${result.metadata.cacheHits}`);
console.log(`  Parallel levels: ${result.metadata.parallelLevels}`);

// Show individual results
for (const toolResult of result.results) {
  if (toolResult.success) {
    console.log(`✓ ${toolResult.toolName}`);
  } else {
    console.log(`✗ ${toolResult.toolName}: ${toolResult.error?.message}`);
  }
}
</codeblock>
    <section><title>4.9 Interactive Approval System</title></section>
    <p>For destructive operations, we need user approval. Let&apos;s implement a robust approval system.</p>
    <section><title>Approval Manager</title></section>
    <codeblock outputclass="language-typescript">/**
 * Manages approval workflows for destructive operations
 */
export class ApprovalManager {
  private logger: Logger;
  private autoApprove: Set&lt;string&gt;;
  private alwaysDeny: Set&lt;string&gt;;

  constructor(logger: Logger) {
    this.logger = logger;
    this.autoApprove = new Set();
    this.alwaysDeny = new Set();
  }

  /**
   * Request approval for a tool call
   */
  async requestApproval(
    call: ToolCall,
    tool: Tool,
    promptCallback: ApprovalPromptCallback
  ): Promise&lt;ApprovalResult&gt; {
    // Check auto-approve list
    if (this.autoApprove.has(tool.name)) {
      this.logger.debug(`Auto-approved: ${tool.name}`);
      return {
        approved: true,
        remember: true
      };
    }

    // Check always-deny list
    if (this.alwaysDeny.has(tool.name)) {
      this.logger.debug(`Auto-denied: ${tool.name}`);
      return {
        approved: false,
        remember: true
      };
    }

    // Prompt user
    const result = await promptCallback({
      toolName: tool.name,
      description: tool.description,
      parameters: call.parameters,
      impact: this.assessImpact(tool, call)
    });

    // Remember choice if requested
    if (result.remember) {
      if (result.approved) {
        this.autoApprove.add(tool.name);
      } else {
        this.alwaysDeny.add(tool.name);
      }
    }

    return result;
  }

  /**
   * Assess impact of tool execution
   */
  private assessImpact(tool: Tool, call: ToolCall): ImpactAssessment {
    const impact: ImpactAssessment = {
      level: &apos;low&apos;,
      description: &apos;&apos;,
      warnings: []
    };

    // Assess based on tool type
    if (tool.name.includes(&apos;delete&apos;)) {
      impact.level = &apos;high&apos;;
      impact.description = &apos;This operation will delete data permanently&apos;;
      impact.warnings.push(&apos;⚠️  Cannot be undone&apos;);
    } else if (tool.name.includes(&apos;write&apos;) || tool.name.includes(&apos;commit&apos;)) {
      impact.level = &apos;medium&apos;;
      impact.description = &apos;This operation will modify files&apos;;
      if (call.parameters.path) {
        impact.warnings.push(`📝 Will modify: ${call.parameters.path}`);
      }
    } else if (tool.name.includes(&apos;push&apos;) || tool.name.includes(&apos;deploy&apos;)) {
      impact.level = &apos;high&apos;;
      impact.description = &apos;This operation will affect remote systems&apos;;
      impact.warnings.push(&apos;🌐 Remote operation - affects others&apos;);
    }

    return impact;
  }

  /**
   * Clear approval memory
   */
  clearMemory(): void {
    this.autoApprove.clear();
    this.alwaysDeny.clear();
    this.logger.debug(&apos;Cleared approval memory&apos;);
  }

  /**
   * Get approval statistics
   */
  getStats(): ApprovalStats {
    return {
      autoApproveCount: this.autoApprove.size,
      alwaysDenyCount: this.alwaysDeny.size,
      autoApproveTools: Array.from(this.autoApprove),
      alwaysDenyTools: Array.from(this.alwaysDeny)
    };
  }
}

interface ApprovalPromptCallback {
  (prompt: ApprovalPrompt): Promise&lt;ApprovalResult&gt;;
}

interface ApprovalPrompt {
  toolName: string;
  description: string;
  parameters: any;
  impact: ImpactAssessment;
}

interface ApprovalResult {
  approved: boolean;
  remember?: boolean; // Remember this choice
}

interface ImpactAssessment {
  level: &apos;low&apos; | &apos;medium&apos; | &apos;high&apos;;
  description: string;
  warnings: string[];
}

interface ApprovalStats {
  autoApproveCount: number;
  alwaysDenyCount: number;
  autoApproveTools: string[];
  alwaysDenyTools: string[];
}
</codeblock>
    <section><title>Terminal Approval UI</title></section>
    <codeblock outputclass="language-typescript">/**
 * Terminal-based approval UI
 */
export class TerminalApprovalUI {
  private readline: readline.Interface;

  constructor() {
    this.readline = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
  }

  /**
   * Prompt user for approval
   */
  async prompt(promptData: ApprovalPrompt): Promise&lt;ApprovalResult&gt; {
    // Display tool information
    console.log(&apos;\n&apos; + &apos;=&apos;.repeat(60));
    console.log(`🔧 Tool: ${promptData.toolName}`);
    console.log(`📄 ${promptData.description}`);
    console.log(&apos;=&apos;.repeat(60));

    // Display parameters
    console.log(&apos;\n📋 Parameters:&apos;);
    console.log(JSON.stringify(promptData.parameters, null, 2));

    // Display impact assessment
    const impactIcon = {
      low: &apos;✅&apos;,
      medium: &apos;⚠️&apos;,
      high: &apos;🔴&apos;
    }[promptData.impact.level];

    console.log(`\n${impactIcon} Impact: ${promptData.impact.level.toUpperCase()}`);
    console.log(`   ${promptData.impact.description}`);

    if (promptData.impact.warnings.length &gt; 0) {
      console.log(&apos;\n⚠️  Warnings:&apos;);
      for (const warning of promptData.impact.warnings) {
        console.log(`   ${warning}`);
      }
    }

    // Prompt for approval
    console.log(&apos;\nOptions:&apos;);
    console.log(&apos;  y  - Approve&apos;);
    console.log(&apos;  n  - Deny&apos;);
    console.log(&apos;  ya - Approve and remember (auto-approve this tool)&apos;);
    console.log(&apos;  na - Deny and remember (always deny this tool)&apos;);

    const answer = await this.question(&apos;\nYour choice: &apos;);

    const approved = answer.toLowerCase().startsWith(&apos;y&apos;);
    const remember = answer.toLowerCase().endsWith(&apos;a&apos;);

    return { approved, remember };
  }

  /**
   * Prompt user with a question
   */
  private question(prompt: string): Promise&lt;string&gt; {
    return new Promise((resolve) =&gt; {
      this.readline.question(prompt, (answer) =&gt; {
        resolve(answer);
      });
    });
  }

  /**
   * Close the UI
   */
  close(): void {
    this.readline.close();
  }
}
</codeblock>
    <section><title>Integration with Orchestrator</title></section>
    <codeblock outputclass="language-typescript">// Using approval system with orchestrator

const approvalManager = new ApprovalManager(logger);
const approvalUI = new TerminalApprovalUI();

const result = await orchestrator.execute(toolCalls, {
  parallelExecution: true,
  enableCache: true,
  approvalCallback: async (call, tool) =&gt; {
    // Use approval manager
    const result = await approvalManager.requestApproval(
      call,
      tool,
      async (prompt) =&gt; await approvalUI.prompt(prompt)
    );

    return result.approved;
  }
});

// Cleanup
approvalUI.close();

// Show approval stats
const stats = approvalManager.getStats();
console.log(`\nApproval Statistics:`);
console.log(`  Auto-approve: ${stats.autoApproveTools.join(&apos;, &apos;)}`);
console.log(`  Always deny: ${stats.alwaysDenyTools.join(&apos;, &apos;)}`);
</codeblock>
    <section><title>4.10 Error Handling and Recovery</title></section>
    <p>Robust error handling is crucial for production systems. Let&apos;s implement comprehensive error recovery.</p>
    <section><title>Error Categories</title></section>
    <codeblock outputclass="language-typescript">/**
 * Error categories for tool execution
 */
export enum ToolErrorCategory {
  // Validation errors (bad input)
  VALIDATION = &apos;VALIDATION&apos;,

  // Permission errors (access denied)
  PERMISSION = &apos;PERMISSION&apos;,

  // Not found errors (file/resource missing)
  NOT_FOUND = &apos;NOT_FOUND&apos;,

  // Timeout errors
  TIMEOUT = &apos;TIMEOUT&apos;,

  // Network errors (external APIs)
  NETWORK = &apos;NETWORK&apos;,

  // System errors (out of memory, etc.)
  SYSTEM = &apos;SYSTEM&apos;,

  // Unknown errors
  UNKNOWN = &apos;UNKNOWN&apos;
}

/**
 * Categorize error by analyzing error object
 */
export function categorizeError(error: any): ToolErrorCategory {
  const message = error.message?.toLowerCase() || &apos;&apos;;
  const code = error.code?.toUpperCase() || &apos;&apos;;

  // Check error codes first
  if (code === &apos;ENOENT&apos;) return ToolErrorCategory.NOT_FOUND;
  if (code === &apos;EACCES&apos; || code === &apos;EPERM&apos;) return ToolErrorCategory.PERMISSION;
  if (code === &apos;ETIMEDOUT&apos; || code === &apos;ESOCKETTIMEDOUT&apos;) return ToolErrorCategory.TIMEOUT;
  if (code === &apos;ENOTFOUND&apos; || code === &apos;ECONNREFUSED&apos;) return ToolErrorCategory.NETWORK;

  // Check error messages
  if (message.includes(&apos;not found&apos;)) return ToolErrorCategory.NOT_FOUND;
  if (message.includes(&apos;permission&apos;) || message.includes(&apos;access denied&apos;)) {
    return ToolErrorCategory.PERMISSION;
  }
  if (message.includes(&apos;timeout&apos;) || message.includes(&apos;timed out&apos;)) {
    return ToolErrorCategory.TIMEOUT;
  }
  if (message.includes(&apos;validation&apos;) || message.includes(&apos;invalid&apos;)) {
    return ToolErrorCategory.VALIDATION;
  }
  if (message.includes(&apos;network&apos;) || message.includes(&apos;connection&apos;)) {
    return ToolErrorCategory.NETWORK;
  }

  return ToolErrorCategory.UNKNOWN;
}
</codeblock>
    <section><title>Retry Strategy</title></section>
    <codeblock outputclass="language-typescript">/**
 * Retry strategy for tool execution
 */
export class RetryStrategy {
  private logger: Logger;
  private maxRetries: number;
  private retryDelay: number;
  private backoffMultiplier: number;

  constructor(
    logger: Logger,
    options: RetryOptions = {}
  ) {
    this.logger = logger;
    this.maxRetries = options.maxRetries || 3;
    this.retryDelay = options.retryDelayMs || 1000;
    this.backoffMultiplier = options.backoffMultiplier || 2;
  }

  /**
   * Execute with retry
   */
  async executeWithRetry&lt;T&gt;(
    operation: () =&gt; Promise&lt;T&gt;,
    context: RetryContext
  ): Promise&lt;T&gt; {
    let lastError: any;
    let attempt = 0;

    while (attempt &lt;= this.maxRetries) {
      try {
        this.logger.debug(`${context.name}: Attempt ${attempt + 1}/${this.maxRetries + 1}`);
        return await operation();
      } catch (error: any) {
        lastError = error;
        attempt++;

        // Categorize error
        const category = categorizeError(error);

        // Check if error is retryable
        if (!this.isRetryable(category)) {
          this.logger.error(`${context.name}: Non-retryable error (${category})`);
          throw error;
        }

        // Check if we have retries left
        if (attempt &gt; this.maxRetries) {
          this.logger.error(`${context.name}: Max retries (${this.maxRetries}) exceeded`);
          throw error;
        }

        // Calculate delay with exponential backoff
        const delay = this.retryDelay * Math.pow(this.backoffMultiplier, attempt - 1);

        this.logger.warn(
          `${context.name}: Attempt ${attempt} failed (${category}), ` +
          `retrying in ${delay}ms...`
        );

        await this.sleep(delay);
      }
    }

    throw lastError;
  }

  /**
   * Check if error category is retryable
   */
  private isRetryable(category: ToolErrorCategory): boolean {
    switch (category) {
      case ToolErrorCategory.TIMEOUT:
      case ToolErrorCategory.NETWORK:
      case ToolErrorCategory.SYSTEM:
        return true;

      case ToolErrorCategory.VALIDATION:
      case ToolErrorCategory.PERMISSION:
      case ToolErrorCategory.NOT_FOUND:
        return false;

      case ToolErrorCategory.UNKNOWN:
        return true; // Retry unknown errors (conservative approach)

      default:
        return false;
    }
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise&lt;void&gt; {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
  }
}

interface RetryOptions {
  maxRetries?: number;
  retryDelayMs?: number;
  backoffMultiplier?: number;
}

interface RetryContext {
  name: string;
  toolName: string;
  callId: string;
}
</codeblock>
    <section><title>Enhanced Tool Execution with Retry</title></section>
    <codeblock outputclass="language-typescript">/**
 * Enhanced tool orchestrator with retry support
 */
export class RobustToolOrchestrator extends ToolOrchestrator {
  private retryStrategy: RetryStrategy;

  constructor(
    registry: ToolRegistry,
    logger: Logger,
    workingDirectory: string,
    options: OrchestratorOptions = {}
  ) {
    super(registry, logger, workingDirectory, options);
    this.retryStrategy = new RetryStrategy(logger, options.retry);
  }

  /**
   * Execute tool call with retry
   */
  protected async executeToolCall(
    call: ToolCall,
    options: ExecutionOptions
  ): Promise&lt;ToolResult&gt; {
    const tool = this.registry.get(call.toolName);

    // Only retry if tool is marked as retryable
    if (!tool.retryable) {
      return await super.executeToolCall(call, options);
    }

    // Execute with retry
    try {
      return await this.retryStrategy.executeWithRetry(
        async () =&gt; await super.executeToolCall(call, options),
        {
          name: `Tool ${call.toolName}`,
          toolName: call.toolName,
          callId: call.id
        }
      );
    } catch (error: any) {
      // If all retries failed, return error result
      return {
        callId: call.id,
        toolName: call.toolName,
        success: false,
        error: {
          message: error.message,
          code: categorizeError(error),
          recoverable: false,
          suggestion: this.getSuggestion(error)
        },
        metadata: {
          durationMs: 0,
          cached: false,
          timestamp: new Date(),
          retriesAttempted: this.retryStrategy[&apos;maxRetries&apos;]
        }
      };
    }
  }

  /**
   * Get suggestion based on error
   */
  private getSuggestion(error: any): string {
    const category = categorizeError(error);

    switch (category) {
      case ToolErrorCategory.NOT_FOUND:
        return &apos;Check that the file or resource exists&apos;;

      case ToolErrorCategory.PERMISSION:
        return &apos;Check file permissions or access rights&apos;;

      case ToolErrorCategory.TIMEOUT:
        return &apos;Try increasing the timeout or check system resources&apos;;

      case ToolErrorCategory.NETWORK:
        return &apos;Check network connectivity and try again&apos;;

      case ToolErrorCategory.VALIDATION:
        return &apos;Check parameter values and format&apos;;

      default:
        return &apos;Check logs for more details&apos;;
    }
  }
}
</codeblock>
    <section><title>Summary</title></section>
    <p>In this chapter, we&apos;ve built a complete tool orchestration system with:</p>
    <ol>
      <li>
        <b>Tool Interface</b>
        - Clean, declarative contracts for all tools
      </li>
      <li>
        <b>Tool Implementations</b>
        - File system, git, and code analysis tools
      </li>
      <li>
        <b>Tool Registry</b>
        - Central catalog with dependency validation
      </li>
      <li>
        <b>Dependency Resolution</b>
        - DAG construction and topological sorting
      </li>
      <li>
        <b>Parallel Execution</b>
        - Concurrent execution with dependency tracking
      </li>
      <li>
        <b>Result Caching</b>
        - Avoid redundant work for deterministic operations
      </li>
      <li>
        <b>Tool Orchestrator</b>
        - Main coordinator integrating all components
      </li>
      <li>
        <b>Interactive Approval</b>
        - Safety mechanisms for destructive operations
      </li>
      <li>
        <b>Error Handling</b>
        - Categorization, retry logic, and graceful degradation
      </li>
    </ol>
    <section><title>Key Takeaways</title></section>
    <p>✅ <b>Tools are the bridge</b> between AI reasoning and real-world actions</p>
    <p>✅ <b>Declarative design</b> separates tool capabilities from orchestration logic</p>
    <p>✅ <b>Dependency graphs</b> enable optimal execution planning</p>
    <p>✅ <b>Parallel execution</b> dramatically improves performance</p>
    <p>✅ <b>Caching</b> avoids redundant work for deterministic operations</p>
    <p>✅ <b>Approval workflows</b> prevent accidental destructive operations</p>
    <p>✅ <b>Retry logic</b> handles transient failures gracefully</p>
    <p>✅ <b>Rich error information</b> enables better error recovery and user guidance</p>
    <section><title>Exercises</title></section>
    <section><title>Exercise 1: Implement Custom Tools</title></section>
    <p>Create three custom tools for your domain:</p>
    <p><b>Starter Code:</b></p>
    <codeblock outputclass="language-typescript">// 1. Database Query Tool
export class DatabaseQueryTool implements Tool {
  readonly name = &apos;query_database&apos;;
  readonly description = &apos;Execute SQL query against database&apos;;
  // TODO: Implement
}

// 2. API Call Tool
export class APICallTool implements Tool {
  readonly name = &apos;api_call&apos;;
  readonly description = &apos;Make HTTP request to external API&apos;;
  // TODO: Implement
}

// 3. Code Generation Tool
export class CodeGenerationTool implements Tool {
  readonly name = &apos;generate_code&apos;;
  readonly description = &apos;Generate code from template&apos;;
  // TODO: Implement
}
</codeblock>
    <p><b>Requirements:</b>
- Follow tool interface design principles
- Include proper error handling
- Implement validation
- Add cost estimation
- Write unit tests</p>
    <section><title>Exercise 2: Dependency Optimization</title></section>
    <p>Optimize the dependency resolver to minimize execution time:</p>
    <p><b>Task:</b></p>
    <codeblock outputclass="language-typescript">// Given these tool calls, find the optimal execution plan
const toolCalls = [
  { id: &apos;1&apos;, toolName: &apos;fetch_data&apos;, params: { source: &apos;api1&apos; } },
  { id: &apos;2&apos;, toolName: &apos;fetch_data&apos;, params: { source: &apos;api2&apos; } },
  { id: &apos;3&apos;, toolName: &apos;process_data&apos;, params: {}, dependsOn: [&apos;1&apos;] },
  { id: &apos;4&apos;, toolName: &apos;process_data&apos;, params: {}, dependsOn: [&apos;2&apos;] },
  { id: &apos;5&apos;, toolName: &apos;merge_results&apos;, params: {}, dependsOn: [&apos;3&apos;, &apos;4&apos;] },
  { id: &apos;6&apos;, toolName: &apos;generate_report&apos;, params: {}, dependsOn: [&apos;5&apos;] }
];

// TODO: Calculate optimal parallel levels
// TODO: Estimate total execution time
// TODO: Identify bottlenecks
</codeblock>
    <section><title>Exercise 3: Cache Eviction Strategies</title></section>
    <p>Implement advanced cache eviction strategies:</p>
    <p><b>Starter Code:</b></p>
    <codeblock outputclass="language-typescript">export enum EvictionStrategy {
  LRU,  // Least Recently Used
  LFU,  // Least Frequently Used
  TTL,  // Time To Live
  SIZE  // Size-based
}

export class AdvancedCache extends ResultCache {
  constructor(
    logger: Logger,
    strategy: EvictionStrategy,
    options: CacheOptions
  ) {
    super(logger, options);
    // TODO: Implement eviction strategy
  }

  // TODO: Track access frequency
  // TODO: Track access recency
  // TODO: Track entry sizes
  // TODO: Implement smart eviction
}
</codeblock>
    <section><title>Exercise 4: Approval Policies</title></section>
    <p>Create a policy-based approval system:</p>
    <p><b>Task:</b></p>
    <codeblock outputclass="language-typescript">interface ApprovalPolicy {
  // Define when approval is needed
  requiresApproval(tool: Tool, params: any): boolean;

  // Define approval level (user, admin, auto)
  getApprovalLevel(tool: Tool, params: any): ApprovalLevel;

  // Auto-approve based on rules
  autoApprove(tool: Tool, params: any): boolean;
}

// TODO: Implement policy for file operations
// TODO: Implement policy for git operations
// TODO: Implement policy for external API calls
// TODO: Add policy composition (AND, OR, NOT)
</codeblock>
    <section><title>Exercise 5: Performance Benchmarking</title></section>
    <p>Benchmark tool orchestration performance:</p>
    <p><b>Requirements:</b></p>
    <codeblock outputclass="language-typescript">// Compare performance scenarios:

// 1. Sequential vs Parallel execution
// 2. Cache enabled vs disabled
// 3. Different concurrency limits (1, 5, 10, unlimited)
// 4. Impact of retry logic
// 5. Overhead of approval workflows

// TODO: Create benchmark suite
// TODO: Collect metrics (duration, throughput, cache hit rate)
// TODO: Generate performance report
// TODO: Identify optimization opportunities
</codeblock>
    <p><b>Next Chapter:</b> Streaming Architecture and Real-Time Responses →</p>
    <p>In Chapter 5, we&apos;ll explore how to stream AI responses and tool execution progress in real-time, providing immediate feedback to users and enabling responsive UX.</p>
    <p><i>Chapter 4 | Tool Orchestration and Execution | Complete</i></p>
  </body>
</topic>