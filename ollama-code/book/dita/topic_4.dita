<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_4">
  <title>Chapter 3: Dependency Injection for AI Systems</title>
  <body>
    <section><title>Introduction</title></section>
    <p>In the previous chapters, we built a sophisticated multi-provider AI system with providers, routers, fusion strategies, and managers. But there&apos;s a critical question we haven&apos;t addressed: <b>How do all these components find each other?</b></p>
    <p>Consider this scenario:</p>
    <codeblock outputclass="language-typescript">// The Router needs the ProviderManager
const router = new IntelligentRouter(providerManager, logger);

// But the ProviderManager needs the Router for some operations
const providerManager = new ProviderManager(router, logger);

// Circular dependency! üîÑ
</codeblock>
    <p>Or this one:</p>
    <codeblock outputclass="language-typescript">// ConversationManager needs AI completion
const conversationManager = new ConversationManager(router);

// ToolOrchestrator also needs AI completion
const toolOrchestrator = new ToolOrchestrator(router);

// VCSIntelligence needs both
const vcsIntelligence = new VCSIntelligence(conversationManager, toolOrchestrator);

// Who creates what? In what order? ü§î
</codeblock>
    <p>These are the challenges <b>Dependency Injection (DI)</b> solves. In this chapter, we&apos;ll explore:</p>
    <ol>
      <li>
        Why traditional patterns fail for complex AI systems
      </li>
      <li>
        How to design a DI container for TypeScript
      </li>
      <li>
        Service lifecycle management
      </li>
      <li>
        Circular dependency resolution
      </li>
      <li>
        Testing with DI
      </li>
      <li>
        Production deployment patterns
      </li>
    </ol>
    <p>By the end, you&apos;ll have a complete, production-ready DI system powering the entire <b>ollama-code</b> architecture.</p>
    <section><title>3.1 Why Dependency Injection?</title></section>
    <section><title>The Problem: Manual Dependency Management</title></section>
    <p>Without DI, creating the full system looks like this:</p>
    <codeblock outputclass="language-typescript">// Bad: Manual dependency management nightmare
async function bootstrap() {
  // Create logger first
  const logger = new Logger({ level: &apos;info&apos; });

  // Create provider manager
  const providerManager = new ProviderManager(logger);

  // Register providers
  const ollama = new OllamaProvider({ baseUrl: &apos;http://localhost:11434&apos; });
  await ollama.initialize();
  await providerManager.registerProvider(&apos;ollama-local&apos;, ollama);

  const openai = new OpenAIProvider({ apiKey: process.env.OPENAI_API_KEY! });
  await openai.initialize();
  await providerManager.registerProvider(&apos;openai-main&apos;, openai);

  // Create router
  const router = new IntelligentRouter(providerManager, logger);

  // Create fusion
  const fusion = new MajorityVotingFusion(router, logger);

  // Create conversation manager
  const conversationManager = new ConversationManager(router, logger);

  // Create tool orchestrator (needs router AND conversation manager)
  const toolOrchestrator = new ToolOrchestrator(router, conversationManager, logger);

  // Create VCS intelligence (needs multiple dependencies)
  const vcsIntelligence = new VCSIntelligence(
    router,
    conversationManager,
    toolOrchestrator,
    logger
  );

  // Create terminal interface
  const terminal = new TerminalInterface(logger);

  // Create main app (needs EVERYTHING)
  const app = new OllamaCodeApp(
    router,
    fusion,
    conversationManager,
    toolOrchestrator,
    vcsIntelligence,
    terminal,
    logger
  );

  return app;
}
</codeblock>
    <p><b>Problems:</b></p>
    <ol>
      <li>
        ‚ùå
        <b>Order matters</b>
        : Create dependencies before dependents
      </li>
      <li>
        ‚ùå
        <b>Duplicated logic</b>
        : Initialization scattered everywhere
      </li>
      <li>
        ‚ùå
        <b>Hard to test</b>
        : Can&apos;t easily mock dependencies
      </li>
      <li>
        ‚ùå
        <b>Brittle</b>
        : Adding a dependency requires changing multiple files
      </li>
      <li>
        ‚ùå
        <b>No lifecycle management</b>
        : When do we dispose resources?
      </li>
      <li>
        ‚ùå
        <b>Circular dependencies</b>
        : Can&apos;t be expressed
      </li>
    </ol>
    <section><title>The Solution: Dependency Injection</title></section>
    <p>With DI, it looks like this:</p>
    <codeblock outputclass="language-typescript">// Good: DI container manages everything
async function bootstrap() {
  const container = new DIContainer();

  // Register services
  container.register(&apos;logger&apos;, Logger, { singleton: true });
  container.register(&apos;providerManager&apos;, ProviderManager, { singleton: true });
  container.register(&apos;router&apos;, IntelligentRouter, { singleton: true });
  container.register(&apos;fusion&apos;, MajorityVotingFusion, { singleton: true });
  container.register(&apos;conversationManager&apos;, ConversationManager, { singleton: true });
  container.register(&apos;toolOrchestrator&apos;, ToolOrchestrator, { singleton: true });
  container.register(&apos;vcsIntelligence&apos;, VCSIntelligence, { singleton: true });
  container.register(&apos;terminal&apos;, TerminalInterface, { singleton: true });
  container.register(&apos;app&apos;, OllamaCodeApp, { singleton: true });

  // Container resolves all dependencies automatically
  const app = await container.resolve&lt;OllamaCodeApp&gt;(&apos;app&apos;);

  return app;
}
</codeblock>
    <p><b>Benefits:</b></p>
    <ol>
      <li>
        ‚úÖ
        <b>Automatic resolution</b>
        : Container figures out the order
      </li>
      <li>
        ‚úÖ
        <b>Centralized configuration</b>
        : All registrations in one place
      </li>
      <li>
        ‚úÖ
        <b>Easy testing</b>
        : Swap implementations with mocks
      </li>
      <li>
        ‚úÖ
        <b>Flexible</b>
        : Change implementations without touching code
      </li>
      <li>
        ‚úÖ
        <b>Lifecycle management</b>
        : Container handles disposal
      </li>
      <li>
        ‚úÖ
        <b>Circular dependency detection</b>
        : Container catches and reports issues
      </li>
    </ol>
    <section><title>Real-World Benefits in ollama-code</title></section>
    <section><title>Before DI: Tight Coupling</title></section>
    <codeblock outputclass="language-typescript">// ConversationManager directly creates dependencies
export class ConversationManager {
  private router: IntelligentRouter;

  constructor() {
    // Hard-coded dependency creation
    const providerManager = new ProviderManager(new Logger());
    this.router = new IntelligentRouter(providerManager, new Logger());
  }

  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    return await this.router.route({ prompt, complexity: &apos;medium&apos; });
  }
}

// Problems:
// - Can&apos;t test with mock router
// - Always uses real ProviderManager
// - Creates new Logger instead of sharing
</codeblock>
    <section><title>After DI: Loose Coupling</title></section>
    <codeblock outputclass="language-typescript">// ConversationManager receives dependencies
export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger
  ) {}

  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    return await this.router.route({ prompt, complexity: &apos;medium&apos; });
  }
}

// Benefits:
// - Easy to test with mock router
// - Container decides which implementations to use
// - Shared logger instance across all services
</codeblock>
    <section><title>Testing Comparison</title></section>
    <section><title>Without DI: Hard to Test</title></section>
    <codeblock outputclass="language-typescript">// Test is forced to use real dependencies
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should analyze prompt&apos;, async () =&gt; {
    // Must create all real dependencies
    const manager = new ConversationManager();

    // Calls real AI providers! Slow, expensive, unreliable
    const result = await manager.analyze(&apos;test prompt&apos;);

    expect(result).toBeDefined();
  });
});
</codeblock>
    <section><title>With DI: Easy to Test</title></section>
    <codeblock outputclass="language-typescript">// Test injects mock dependencies
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should analyze prompt&apos;, async () =&gt; {
    // Create mock router
    const mockRouter = {
      route: vi.fn().mockResolvedValue({
        providerId: &apos;test&apos;,
        model: &apos;test-model&apos;,
        reasoning: &apos;test&apos;,
        estimatedCost: 0,
        fallbacks: [],
        confidence: 1.0
      })
    };

    const mockLogger = { info: vi.fn(), error: vi.fn() };

    // Inject mocks
    const manager = new ConversationManager(mockRouter as any, mockLogger as any);

    const result = await manager.analyze(&apos;test prompt&apos;);

    expect(mockRouter.route).toHaveBeenCalledWith({
      prompt: &apos;test prompt&apos;,
      complexity: &apos;medium&apos;
    });
    expect(result).toBeDefined();
  });
});
</codeblock>
    <section><title>Summary: When to Use DI</title></section>
    <p>Use Dependency Injection when:</p>
    <p>‚úÖ <b>Your system has 5+ components</b> that depend on each other
‚úÖ <b>You need to test</b> components in isolation
‚úÖ <b>You have multiple implementations</b> of the same interface
‚úÖ <b>Component lifecycle matters</b> (initialization, disposal)
‚úÖ <b>Configuration changes</b> between environments (dev, test, prod)</p>
    <p>Don&apos;t overcomplicate simple systems:</p>
    <p>‚ùå <b>Simple scripts</b> with 1-2 files don&apos;t need DI
‚ùå <b>Stateless functions</b> don&apos;t need DI
‚ùå <b>Configuration-only</b> (no behavior) doesn&apos;t need DI</p>
    <p>For <b>ollama-code</b>, with 15+ components, multiple providers, and complex testing needs, DI is essential.</p>
    <section><title>3.2 Container Architecture</title></section>
    <p>Let&apos;s design a production-ready DI container for TypeScript. We&apos;ll build it step by step, starting with core concepts.</p>
    <section><title>Core Concepts</title></section>
    <section><title>1. Service Registration</title></section>
    <p>A <b>service</b> is any class or factory function that provides functionality. Services are <b>registered</b> with a unique key:</p>
    <codeblock outputclass="language-typescript">container.register(&apos;logger&apos;, Logger);
container.register(&apos;router&apos;, IntelligentRouter);
</codeblock>
    <section><title>2. Service Resolution</title></section>
    <p><b>Resolution</b> is the process of creating an instance of a service, including all its dependencies:</p>
    <codeblock outputclass="language-typescript">const logger = await container.resolve&lt;Logger&gt;(&apos;logger&apos;);
const router = await container.resolve&lt;IntelligentRouter&gt;(&apos;router&apos;);
</codeblock>
    <section><title>3. Service Lifetime</title></section>
    <p>Services have different <b>lifetimes</b>:</p>
    <ul>
      <li>
        <b>Transient</b>
        : New instance every time
      </li>
      <li>
        <b>Singleton</b>
        : Single instance shared across entire application
      </li>
      <li>
        <b>Scoped</b>
        : Single instance within a scope (e.g., per request)
      </li>
    </ul>
    <codeblock outputclass="language-typescript">// Singleton: shared logger
container.register(&apos;logger&apos;, Logger, { singleton: true });

// Transient: new instance each time
container.register(&apos;tempAnalyzer&apos;, Analyzer, { singleton: false });
</codeblock>
    <section><title>4. Dependency Graph</title></section>
    <p>The container builds a <b>dependency graph</b> to determine creation order:</p>
    <codeblock>App
 ‚îú‚îÄ Router
 ‚îÇ   ‚îú‚îÄ ProviderManager
 ‚îÇ   ‚îÇ   ‚îî‚îÄ Logger
 ‚îÇ   ‚îî‚îÄ Logger (shared)
 ‚îî‚îÄ ConversationManager
     ‚îú‚îÄ Router (shared)
     ‚îî‚îÄ Logger (shared)
</codeblock>
    <section><title>Container Interface</title></section>
    <codeblock outputclass="language-typescript">/**
 * Service registration options
 */
export interface ServiceOptions {
  /** If true, create singleton (default: true) */
  singleton?: boolean;

  /** Factory function to create instance */
  factory?: (container: DIContainer) =&gt; any | Promise&lt;any&gt;;

  /** Dependencies to inject (auto-detected if not specified) */
  dependencies?: string[];

  /** Lifecycle hooks */
  lifecycle?: {
    onInit?: (instance: any) =&gt; Promise&lt;void&gt; | void;
    onDispose?: (instance: any) =&gt; Promise&lt;void&gt; | void;
  };
}

/**
 * Service definition
 */
interface ServiceDefinition {
  key: string;
  constructor?: new (...args: any[]) =&gt; any;
  factory?: (container: DIContainer) =&gt; any | Promise&lt;any&gt;;
  options: ServiceOptions;
  instance?: any;
  dependencies: string[];
}

/**
 * Dependency Injection Container
 */
export class DIContainer {
  private services = new Map&lt;string, ServiceDefinition&gt;();
  private resolving = new Set&lt;string&gt;();
  private initialized = new Set&lt;string&gt;();

  /**
   * Register a service
   */
  register&lt;T&gt;(
    key: string,
    constructor: new (...args: any[]) =&gt; T,
    options: ServiceOptions = {}
  ): void {
    // Implementation coming next
  }

  /**
   * Resolve a service (create or return cached instance)
   */
  async resolve&lt;T&gt;(key: string): Promise&lt;T&gt; {
    // Implementation coming next
  }

  /**
   * Check if service is registered
   */
  has(key: string): boolean {
    return this.services.has(key);
  }

  /**
   * Dispose all services
   */
  async dispose(): Promise&lt;void&gt; {
    // Implementation coming next
  }
}
</codeblock>
    <section><title>Registration Implementation</title></section>
    <codeblock outputclass="language-typescript">export class DIContainer {
  private services = new Map&lt;string, ServiceDefinition&gt;();
  private resolving = new Set&lt;string&gt;();
  private initialized = new Set&lt;string&gt;();

  /**
   * Register a service with the container
   */
  register&lt;T&gt;(
    key: string,
    constructor: new (...args: any[]) =&gt; T,
    options: ServiceOptions = {}
  ): void {
    if (this.services.has(key)) {
      throw new Error(`Service &apos;${key}&apos; is already registered`);
    }

    // Default to singleton
    const opts: ServiceOptions = {
      singleton: true,
      ...options
    };

    // Extract dependencies from constructor
    const dependencies = opts.dependencies || this.extractDependencies(constructor);

    const definition: ServiceDefinition = {
      key,
      constructor,
      factory: opts.factory,
      options: opts,
      dependencies
    };

    this.services.set(key, definition);
  }

  /**
   * Register a factory function
   */
  registerFactory&lt;T&gt;(
    key: string,
    factory: (container: DIContainer) =&gt; T | Promise&lt;T&gt;,
    options: ServiceOptions = {}
  ): void {
    if (this.services.has(key)) {
      throw new Error(`Service &apos;${key}&apos; is already registered`);
    }

    const opts: ServiceOptions = {
      singleton: true,
      ...options
    };

    const definition: ServiceDefinition = {
      key,
      factory,
      options: opts,
      dependencies: opts.dependencies || []
    };

    this.services.set(key, definition);
  }

  /**
   * Register an existing instance
   */
  registerInstance&lt;T&gt;(key: string, instance: T): void {
    if (this.services.has(key)) {
      throw new Error(`Service &apos;${key}&apos; is already registered`);
    }

    const definition: ServiceDefinition = {
      key,
      options: { singleton: true },
      instance,
      dependencies: []
    };

    this.services.set(key, definition);
    this.initialized.add(key);
  }

  /**
   * Extract dependencies from constructor parameters
   * This is simplified - in production, use reflect-metadata
   */
  private extractDependencies(constructor: new (...args: any[]) =&gt; any): string[] {
    // Get parameter names from function signature
    const funcStr = constructor.toString();
    const match = funcStr.match(/constructor\s*\(([^)]*)\)/);

    if (!match || !match[1].trim()) {
      return [];
    }

    // Parse parameter list
    const params = match[1]
      .split(&apos;,&apos;)
      .map(p =&gt; p.trim())
      .filter(Boolean);

    // Extract parameter names (simplified - doesn&apos;t handle all cases)
    return params.map(param =&gt; {
      // Handle: &quot;private router: IntelligentRouter&quot;
      const parts = param.split(&apos;:&apos;);
      if (parts.length &gt; 1) {
        const name = parts[0].trim().split(&apos; &apos;).pop()!;
        return name;
      }

      // Handle: &quot;router&quot;
      return param.split(&apos; &apos;).pop()!;
    });
  }
}
</codeblock>
    <section><title>Resolution Implementation</title></section>
    <codeblock outputclass="language-typescript">export class DIContainer {
  // ... previous code ...

  /**
   * Resolve a service (create instance or return cached)
   */
  async resolve&lt;T&gt;(key: string): Promise&lt;T&gt; {
    const definition = this.services.get(key);

    if (!definition) {
      throw new Error(`Service &apos;${key}&apos; is not registered`);
    }

    // Return cached singleton instance
    if (definition.options.singleton &amp;&amp; definition.instance) {
      return definition.instance;
    }

    // Detect circular dependencies
    if (this.resolving.has(key)) {
      const chain = Array.from(this.resolving).join(&apos; -&gt; &apos;) + &apos; -&gt; &apos; + key;
      throw new Error(`Circular dependency detected: ${chain}`);
    }

    try {
      // Mark as resolving
      this.resolving.add(key);

      // Create instance
      const instance = await this.createInstance(definition);

      // Cache singleton
      if (definition.options.singleton) {
        definition.instance = instance;
      }

      // Run lifecycle hook
      if (definition.options.lifecycle?.onInit &amp;&amp; !this.initialized.has(key)) {
        await definition.options.lifecycle.onInit(instance);
        this.initialized.add(key);
      }

      return instance;
    } finally {
      // Done resolving
      this.resolving.delete(key);
    }
  }

  /**
   * Create an instance of a service
   */
  private async createInstance(definition: ServiceDefinition): Promise&lt;any&gt; {
    // Use factory if provided
    if (definition.factory) {
      return await definition.factory(this);
    }

    // Use constructor
    if (!definition.constructor) {
      throw new Error(`Service &apos;${definition.key}&apos; has no constructor or factory`);
    }

    // Resolve dependencies
    const dependencies = await Promise.all(
      definition.dependencies.map(dep =&gt; this.resolve(dep))
    );

    // Create instance with dependencies
    return new definition.constructor(...dependencies);
  }

  /**
   * Resolve multiple services
   */
  async resolveMany&lt;T&gt;(keys: string[]): Promise&lt;T[]&gt; {
    return await Promise.all(keys.map(key =&gt; this.resolve&lt;T&gt;(key)));
  }

  /**
   * Check if service exists
   */
  has(key: string): boolean {
    return this.services.has(key);
  }

  /**
   * Get all registered service keys
   */
  keys(): string[] {
    return Array.from(this.services.keys());
  }
}
</codeblock>
    <section><title>Disposal Implementation</title></section>
    <codeblock outputclass="language-typescript">export class DIContainer {
  // ... previous code ...

  /**
   * Dispose all singleton instances
   */
  async dispose(): Promise&lt;void&gt; {
    const instances: Array&lt;{ key: string; instance: any; onDispose?: Function }&gt; = [];

    // Collect all singleton instances
    for (const [key, definition] of this.services) {
      if (definition.instance) {
        instances.push({
          key,
          instance: definition.instance,
          onDispose: definition.options.lifecycle?.onDispose
        });
      }
    }

    // Dispose in reverse order of initialization
    // (dependents before dependencies)
    instances.reverse();

    for (const { key, instance, onDispose } of instances) {
      try {
        // Call lifecycle hook
        if (onDispose) {
          await onDispose(instance);
        }

        // Call IDisposable.dispose() if exists
        if (typeof instance.dispose === &apos;function&apos;) {
          await instance.dispose();
        }
      } catch (error) {
        console.error(`Error disposing service &apos;${key}&apos;:`, error);
      }
    }

    // Clear state
    this.services.clear();
    this.resolving.clear();
    this.initialized.clear();
  }

  /**
   * Create a child container (for scoping)
   */
  createScope(): DIContainer {
    const scope = new DIContainer();

    // Copy service definitions (but not instances)
    for (const [key, definition] of this.services) {
      scope.services.set(key, {
        ...definition,
        instance: undefined // New scope gets new instances
      });
    }

    return scope;
  }
}
</codeblock>
    <section><title>Usage Example</title></section>
    <codeblock outputclass="language-typescript">// Create container
const container = new DIContainer();

// Register services
container.register(&apos;logger&apos;, Logger, {
  singleton: true,
  lifecycle: {
    onInit: async (logger) =&gt; {
      await logger.initialize();
    },
    onDispose: async (logger) =&gt; {
      await logger.flush();
    }
  }
});

container.register(&apos;providerManager&apos;, ProviderManager, {
  singleton: true,
  dependencies: [&apos;logger&apos;]
});

container.register(&apos;router&apos;, IntelligentRouter, {
  singleton: true,
  dependencies: [&apos;providerManager&apos;, &apos;logger&apos;]
});

container.register(&apos;app&apos;, OllamaCodeApp, {
  singleton: true,
  dependencies: [&apos;router&apos;, &apos;logger&apos;]
});

// Resolve (automatically resolves dependencies)
const app = await container.resolve&lt;OllamaCodeApp&gt;(&apos;app&apos;);

// Use app
await app.run();

// Clean up
await container.dispose();
</codeblock>
    <section><title>3.3 Service Registry Pattern</title></section>
    <p>The <b>Service Registry</b> pattern centralizes service registration, making it easy to configure the entire application in one place.</p>
    <section><title>Registry Implementation</title></section>
    <codeblock outputclass="language-typescript">/**
 * Service registry for centralized configuration
 */
export class ServiceRegistry {
  /**
   * Register all core services
   */
  static registerCoreServices(container: DIContainer): void {
    // Logger - foundational service
    container.register(&apos;logger&apos;, Logger, {
      singleton: true,
      factory: () =&gt; new Logger({
        level: process.env.LOG_LEVEL || &apos;info&apos;,
        format: process.env.LOG_FORMAT || &apos;pretty&apos;
      }),
      lifecycle: {
        onInit: async (logger) =&gt; {
          logger.info(&apos;Logger initialized&apos;);
        },
        onDispose: async (logger) =&gt; {
          logger.info(&apos;Logger disposing&apos;);
          await logger.flush();
        }
      }
    });

    // Provider Manager
    container.register(&apos;providerManager&apos;, ProviderManager, {
      singleton: true,
      dependencies: [&apos;logger&apos;]
    });

    // Intelligent Router
    container.register(&apos;router&apos;, IntelligentRouter, {
      singleton: true,
      dependencies: [&apos;providerManager&apos;, &apos;logger&apos;]
    });

    // Response Fusion
    container.register(&apos;fusion&apos;, MajorityVotingFusion, {
      singleton: true,
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });
  }

  /**
   * Register AI providers
   */
  static async registerProviders(container: DIContainer): Promise&lt;void&gt; {
    const providerManager = await container.resolve&lt;ProviderManager&gt;(&apos;providerManager&apos;);
    const logger = await container.resolve&lt;Logger&gt;(&apos;logger&apos;);

    // Ollama (local)
    if (process.env.OLLAMA_BASE_URL || true) {
      const ollama = new OllamaProvider({
        baseUrl: process.env.OLLAMA_BASE_URL || &apos;http://localhost:11434&apos;,
        defaultModel: process.env.OLLAMA_MODEL || &apos;qwen2.5-coder:7b&apos;
      });

      await ollama.initialize();
      await providerManager.registerProvider(&apos;ollama-local&apos;, ollama);
      logger.info(&apos;Registered Ollama provider&apos;);
    }

    // OpenAI
    if (process.env.OPENAI_API_KEY) {
      const openai = new OpenAIProvider({
        apiKey: process.env.OPENAI_API_KEY,
        organization: process.env.OPENAI_ORG,
        defaultModel: process.env.OPENAI_MODEL || &apos;gpt-4-turbo&apos;
      });

      await openai.initialize();
      await providerManager.registerProvider(&apos;openai-main&apos;, openai);

      // Set budget
      providerManager.setBudget({
        providerId: &apos;openai-main&apos;,
        dailyLimit: parseFloat(process.env.OPENAI_DAILY_LIMIT || &apos;10&apos;),
        monthlyLimit: parseFloat(process.env.OPENAI_MONTHLY_LIMIT || &apos;200&apos;),
        alertThresholds: [0.5, 0.75, 0.9]
      });

      logger.info(&apos;Registered OpenAI provider&apos;);
    }

    // Anthropic
    if (process.env.ANTHROPIC_API_KEY) {
      const anthropic = new AnthropicProvider({
        apiKey: process.env.ANTHROPIC_API_KEY,
        defaultModel: process.env.ANTHROPIC_MODEL || &apos;claude-3-5-sonnet-20241022&apos;
      });

      await anthropic.initialize();
      await providerManager.registerProvider(&apos;anthropic-main&apos;, anthropic);

      providerManager.setBudget({
        providerId: &apos;anthropic-main&apos;,
        dailyLimit: parseFloat(process.env.ANTHROPIC_DAILY_LIMIT || &apos;15&apos;),
        monthlyLimit: parseFloat(process.env.ANTHROPIC_MONTHLY_LIMIT || &apos;300&apos;),
        alertThresholds: [0.5, 0.75, 0.9]
      });

      logger.info(&apos;Registered Anthropic provider&apos;);
    }

    // Google
    if (process.env.GOOGLE_API_KEY) {
      const google = new GoogleProvider({
        apiKey: process.env.GOOGLE_API_KEY,
        defaultModel: process.env.GOOGLE_MODEL || &apos;gemini-1.5-pro&apos;
      });

      await google.initialize();
      await providerManager.registerProvider(&apos;google-main&apos;, google);

      providerManager.setBudget({
        providerId: &apos;google-main&apos;,
        dailyLimit: parseFloat(process.env.GOOGLE_DAILY_LIMIT || &apos;10&apos;),
        monthlyLimit: parseFloat(process.env.GOOGLE_MONTHLY_LIMIT || &apos;200&apos;),
        alertThresholds: [0.5, 0.75, 0.9]
      });

      logger.info(&apos;Registered Google provider&apos;);
    }
  }

  /**
   * Register conversation services
   */
  static registerConversationServices(container: DIContainer): void {
    container.register(&apos;conversationManager&apos;, ConversationManager, {
      singleton: true,
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });

    container.register(&apos;intentAnalyzer&apos;, IntentAnalyzer, {
      singleton: true,
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });

    container.register(&apos;contextEnricher&apos;, ContextEnricher, {
      singleton: true,
      dependencies: [&apos;logger&apos;]
    });
  }

  /**
   * Register tool services
   */
  static registerToolServices(container: DIContainer): void {
    // Tool registry
    container.register(&apos;toolRegistry&apos;, ToolRegistry, {
      singleton: true,
      dependencies: [&apos;logger&apos;]
    });

    // Tool orchestrator
    container.register(&apos;toolOrchestrator&apos;, ToolOrchestrator, {
      singleton: true,
      dependencies: [&apos;toolRegistry&apos;, &apos;router&apos;, &apos;logger&apos;]
    });

    // Streaming orchestrator
    container.register(&apos;streamingOrchestrator&apos;, StreamingToolOrchestrator, {
      singleton: true,
      dependencies: [&apos;toolOrchestrator&apos;, &apos;router&apos;, &apos;logger&apos;]
    });
  }

  /**
   * Register VCS services
   */
  static registerVCSServices(container: DIContainer): void {
    container.register(&apos;vcsIntelligence&apos;, VCSIntelligence, {
      singleton: true,
      dependencies: [&apos;router&apos;, &apos;toolOrchestrator&apos;, &apos;logger&apos;]
    });

    container.register(&apos;commitMessageGenerator&apos;, CommitMessageGenerator, {
      singleton: true,
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });
  }

  /**
   * Register all services
   */
  static async registerAll(container: DIContainer): Promise&lt;void&gt; {
    // Core services
    this.registerCoreServices(container);

    // Conversation services
    this.registerConversationServices(container);

    // Tool services
    this.registerToolServices(container);

    // VCS services
    this.registerVCSServices(container);

    // Register providers (async)
    await this.registerProviders(container);
  }
}
</codeblock>
    <section><title>Bootstrap Function</title></section>
    <codeblock outputclass="language-typescript">/**
 * Bootstrap the application with DI
 */
export async function bootstrap(): Promise&lt;OllamaCodeApp&gt; {
  // Create container
  const container = new DIContainer();

  // Register all services
  await ServiceRegistry.registerAll(container);

  // Register main app
  container.register(&apos;app&apos;, OllamaCodeApp, {
    singleton: true,
    dependencies: [
      &apos;router&apos;,
      &apos;fusion&apos;,
      &apos;conversationManager&apos;,
      &apos;toolOrchestrator&apos;,
      &apos;streamingOrchestrator&apos;,
      &apos;vcsIntelligence&apos;,
      &apos;logger&apos;
    ]
  });

  // Resolve and return app
  return await container.resolve&lt;OllamaCodeApp&gt;(&apos;app&apos;);
}

/**
 * Main entry point
 */
async function main() {
  let app: OllamaCodeApp | null = null;

  try {
    // Bootstrap
    app = await bootstrap();

    // Run
    await app.run(process.argv.slice(2));
  } catch (error) {
    console.error(&apos;Application error:&apos;, error);
    process.exit(1);
  } finally {
    // Clean up
    if (app) {
      await app.dispose();
    }
  }
}

// Run if executed directly
if (require.main === module) {
  main();
}
</codeblock>
    <section><title>3.4 IDisposable Pattern</title></section>
    <p>Managing resource cleanup is critical for long-running AI systems. The <b>IDisposable</b> pattern provides a standard way to release resources when they&apos;re no longer needed.</p>
    <section><title>Why Resource Disposal Matters</title></section>
    <p>AI systems often hold resources that must be explicitly released:</p>
    <ul>
      <li>
        <b>Network connections</b>
        to AI provider APIs
      </li>
      <li>
        <b>File handles</b>
        for logs, credentials, cached data
      </li>
      <li>
        <b>Timers and intervals</b>
        for health monitoring
      </li>
      <li>
        <b>Database connections</b>
        for conversation history
      </li>
      <li>
        <b>Memory buffers</b>
        for streaming responses
      </li>
    </ul>
    <p>Without proper disposal:</p>
    <codeblock outputclass="language-typescript">// Bad: Resources leak
class ProviderManager {
  private healthCheckInterval: NodeJS.Timeout;

  constructor() {
    // Start health monitoring
    this.healthCheckInterval = setInterval(() =&gt; {
      this.checkProviderHealth();
    }, 60000);
  }

  // No dispose method - interval keeps running forever!
}

// Application exits but interval still runs
// Memory leak!
</codeblock>
    <section><title>IDisposable Interface</title></section>
    <codeblock outputclass="language-typescript">/**
 * Interface for disposable resources
 */
export interface IDisposable {
  /**
   * Release all resources held by this object
   */
  dispose(): Promise&lt;void&gt; | void;
}

/**
 * Check if an object is disposable
 */
export function isDisposable(obj: any): obj is IDisposable {
  return obj &amp;&amp; typeof obj.dispose === &apos;function&apos;;
}
</codeblock>
    <section><title>Implementing IDisposable</title></section>
    <section><title>Example 1: Logger with File Handles</title></section>
    <codeblock outputclass="language-typescript">export class Logger implements IDisposable {
  private fileHandle: FileHandle | null = null;
  private buffer: string[] = [];
  private flushInterval: NodeJS.Timeout | null = null;

  async initialize(logFilePath: string): Promise&lt;void&gt; {
    // Open log file
    this.fileHandle = await fs.open(logFilePath, &apos;a&apos;);

    // Flush buffer periodically
    this.flushInterval = setInterval(() =&gt; {
      this.flush();
    }, 5000);
  }

  info(message: string): void {
    this.buffer.push(`[INFO] ${new Date().toISOString()} ${message}\n`);
  }

  error(message: string, error?: any): void {
    const errorMsg = error ? ` ${error.stack || error.message}` : &apos;&apos;;
    this.buffer.push(`[ERROR] ${new Date().toISOString()} ${message}${errorMsg}\n`);
  }

  async flush(): Promise&lt;void&gt; {
    if (!this.fileHandle || this.buffer.length === 0) return;

    const content = this.buffer.join(&apos;&apos;);
    this.buffer = [];

    await this.fileHandle.write(content);
  }

  /**
   * Dispose: flush buffer, close file, clear interval
   */
  async dispose(): Promise&lt;void&gt; {
    // Stop flush interval
    if (this.flushInterval) {
      clearInterval(this.flushInterval);
      this.flushInterval = null;
    }

    // Final flush
    await this.flush();

    // Close file handle
    if (this.fileHandle) {
      await this.fileHandle.close();
      this.fileHandle = null;
    }
  }
}
</codeblock>
    <section><title>Example 2: Provider Manager with Cleanup</title></section>
    <codeblock outputclass="language-typescript">export class ProviderManager implements IDisposable {
  private providers = new Map&lt;string, BaseAIProvider&gt;();
  private healthCheckInterval: NodeJS.Timeout | null = null;
  private usageStats = new Map&lt;string, ProviderUsageStats&gt;();

  constructor(private logger: Logger) {
    // Start health monitoring
    this.healthCheckInterval = setInterval(async () =&gt; {
      await this.checkAllProviderHealth();
    }, 60000);
  }

  async registerProvider(id: string, provider: BaseAIProvider): Promise&lt;void&gt; {
    this.providers.set(id, provider);
    await provider.initialize();
  }

  private async checkAllProviderHealth(): Promise&lt;void&gt; {
    for (const [id, provider] of this.providers) {
      try {
        await provider.performHealthCheck();
      } catch (error) {
        this.logger.error(`Health check failed for ${id}`, error);
      }
    }
  }

  /**
   * Dispose: stop health checks, dispose all providers, save stats
   */
  async dispose(): Promise&lt;void&gt; {
    this.logger.info(&apos;ProviderManager disposing...&apos;);

    // Stop health monitoring
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    // Save usage statistics
    await this.saveUsageStats();

    // Dispose all providers
    for (const [id, provider] of this.providers) {
      try {
        if (isDisposable(provider)) {
          await provider.dispose();
        }
      } catch (error) {
        this.logger.error(`Error disposing provider ${id}`, error);
      }
    }

    this.providers.clear();
    this.usageStats.clear();

    this.logger.info(&apos;ProviderManager disposed&apos;);
  }

  private async saveUsageStats(): Promise&lt;void&gt; {
    const stats = Object.fromEntries(this.usageStats);
    const statsFile = path.join(os.homedir(), &apos;.ollama-code&apos;, &apos;usage-stats.json&apos;);
    await fs.writeFile(statsFile, JSON.stringify(stats, null, 2));
  }
}
</codeblock>
    <section><title>Example 3: Base AI Provider</title></section>
    <codeblock outputclass="language-typescript">export abstract class BaseAIProvider extends EventEmitter implements IDisposable {
  protected config: ProviderConfig;
  protected health: ProviderHealth;
  protected metrics: ProviderMetrics;
  private healthCheckInterval: NodeJS.Timeout | null = null;

  constructor(config: ProviderConfig) {
    super();
    this.config = config;
    this.health = { status: &apos;unknown&apos;, lastCheck: Date.now() };
    this.metrics = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      totalTokensUsed: 0,
      totalCost: 0,
      averageResponseTime: 0
    };

    // Auto health check
    if (config.healthCheckInterval) {
      this.healthCheckInterval = setInterval(async () =&gt; {
        await this.performHealthCheck();
      }, config.healthCheckInterval);
    }
  }

  abstract getName(): string;
  abstract initialize(): Promise&lt;void&gt;;
  abstract complete(prompt: string, options?: CompletionOptions): Promise&lt;AICompletionResponse&gt;;

  /**
   * Dispose provider resources
   */
  async dispose(): Promise&lt;void&gt; {
    // Stop health checks
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    // Remove all event listeners
    this.removeAllListeners();

    // Subclasses can override for additional cleanup
  }
}
</codeblock>
    <section><title>Composite Disposal</title></section>
    <p>When an object contains multiple disposable children:</p>
    <codeblock outputclass="language-typescript">export class OllamaCodeApp implements IDisposable {
  constructor(
    private router: IntelligentRouter,
    private fusion: MajorityVotingFusion,
    private conversationManager: ConversationManager,
    private toolOrchestrator: ToolOrchestrator,
    private vcsIntelligence: VCSIntelligence,
    private terminal: TerminalInterface,
    private logger: Logger
  ) {}

  async run(args: string[]): Promise&lt;void&gt; {
    // Application logic
  }

  /**
   * Dispose all components in reverse order of dependency
   */
  async dispose(): Promise&lt;void&gt; {
    this.logger.info(&apos;Application shutting down...&apos;);

    const components = [
      { name: &apos;VCS Intelligence&apos;, obj: this.vcsIntelligence },
      { name: &apos;Tool Orchestrator&apos;, obj: this.toolOrchestrator },
      { name: &apos;Conversation Manager&apos;, obj: this.conversationManager },
      { name: &apos;Response Fusion&apos;, obj: this.fusion },
      { name: &apos;Router&apos;, obj: this.router },
      { name: &apos;Terminal&apos;, obj: this.terminal },
      { name: &apos;Logger&apos;, obj: this.logger }
    ];

    for (const { name, obj } of components) {
      try {
        if (isDisposable(obj)) {
          this.logger.info(`Disposing ${name}...`);
          await obj.dispose();
        }
      } catch (error) {
        this.logger.error(`Error disposing ${name}`, error);
      }
    }

    this.logger.info(&apos;Application shut down complete&apos;);
  }
}
</codeblock>
    <section><title>Disposal Helper Utilities</title></section>
    <codeblock outputclass="language-typescript">/**
 * Dispose multiple objects
 */
export async function disposeAll(objects: any[]): Promise&lt;void&gt; {
  const errors: Error[] = [];

  for (const obj of objects) {
    try {
      if (isDisposable(obj)) {
        await obj.dispose();
      }
    } catch (error) {
      errors.push(error as Error);
    }
  }

  if (errors.length &gt; 0) {
    throw new AggregateError(errors, &apos;One or more disposals failed&apos;);
  }
}

/**
 * Using statement (C# style)
 */
export async function using&lt;T extends IDisposable, R&gt;(
  resource: T,
  fn: (resource: T) =&gt; Promise&lt;R&gt;
): Promise&lt;R&gt; {
  try {
    return await fn(resource);
  } finally {
    await resource.dispose();
  }
}

// Usage
await using(new Logger({ file: &apos;app.log&apos; }), async (logger) =&gt; {
  logger.info(&apos;Processing...&apos;);
  // Logger automatically disposed after this block
});

/**
 * Disposable scope
 */
export class DisposableScope implements IDisposable {
  private disposables: IDisposable[] = [];

  /**
   * Add a disposable to this scope
   */
  add&lt;T extends IDisposable&gt;(disposable: T): T {
    this.disposables.push(disposable);
    return disposable;
  }

  /**
   * Dispose all in reverse order
   */
  async dispose(): Promise&lt;void&gt; {
    const errors: Error[] = [];

    // Dispose in reverse order (LIFO)
    for (let i = this.disposables.length - 1; i &gt;= 0; i--) {
      try {
        await this.disposables[i].dispose();
      } catch (error) {
        errors.push(error as Error);
      }
    }

    this.disposables = [];

    if (errors.length &gt; 0) {
      throw new AggregateError(errors, &apos;One or more disposals failed&apos;);
    }
  }
}

// Usage
const scope = new DisposableScope();

const logger = scope.add(new Logger({ file: &apos;app.log&apos; }));
const manager = scope.add(new ProviderManager(logger));
const router = scope.add(new IntelligentRouter(manager, logger));

// Use resources...

// Dispose all in reverse order
await scope.dispose();
</codeblock>
    <section><title>Integration with DI Container</title></section>
    <p>The DI container automatically calls <codeph>dispose()</codeph> on singletons:</p>
    <codeblock outputclass="language-typescript">export class DIContainer implements IDisposable {
  // ... previous implementation ...

  /**
   * Dispose all singleton instances
   */
  async dispose(): Promise&lt;void&gt; {
    const instances: Array&lt;{ key: string; instance: any; onDispose?: Function }&gt; = [];

    // Collect all singleton instances
    for (const [key, definition] of this.services) {
      if (definition.instance) {
        instances.push({
          key,
          instance: definition.instance,
          onDispose: definition.options.lifecycle?.onDispose
        });
      }
    }

    // Dispose in reverse order of initialization
    instances.reverse();

    const errors: Error[] = [];

    for (const { key, instance, onDispose } of instances) {
      try {
        // Call lifecycle hook
        if (onDispose) {
          await onDispose(instance);
        }

        // Call IDisposable.dispose() if exists
        if (isDisposable(instance)) {
          await instance.dispose();
        }
      } catch (error) {
        console.error(`Error disposing service &apos;${key}&apos;:`, error);
        errors.push(error as Error);
      }
    }

    // Clear state
    this.services.clear();
    this.resolving.clear();
    this.initialized.clear();

    if (errors.length &gt; 0) {
      throw new AggregateError(errors, &apos;One or more service disposals failed&apos;);
    }
  }
}
</codeblock>
    <section><title>Best Practices</title></section>
    <section><title>1. Always Implement IDisposable for Resources</title></section>
    <codeblock outputclass="language-typescript">// Good: Explicitly implements IDisposable
export class DatabaseConnection implements IDisposable {
  private connection: Connection | null = null;

  async connect(): Promise&lt;void&gt; {
    this.connection = await createConnection(/*...*/);
  }

  async dispose(): Promise&lt;void&gt; {
    if (this.connection) {
      await this.connection.close();
      this.connection = null;
    }
  }
}
</codeblock>
    <section><title>2. Dispose in Reverse Order</title></section>
    <p>Dependencies should be disposed before dependents:</p>
    <codeblock outputclass="language-typescript">// Good: Reverse order disposal
async function shutdown() {
  await app.dispose();          // Depends on router
  await router.dispose();       // Depends on providerManager
  await providerManager.dispose(); // Depends on logger
  await logger.dispose();       // No dependencies
}
</codeblock>
    <section><title>3. Idempotent Disposal</title></section>
    <p><codeph>dispose()</codeph> should be safe to call multiple times:</p>
    <codeblock outputclass="language-typescript">// Good: Idempotent disposal
async dispose(): Promise&lt;void&gt; {
  if (this.disposed) return;
  this.disposed = true;

  // Clean up resources
  if (this.interval) {
    clearInterval(this.interval);
    this.interval = null;
  }

  if (this.connection) {
    await this.connection.close();
    this.connection = null;
  }
}
</codeblock>
    <section><title>4. Handle Disposal Errors</title></section>
    <codeblock outputclass="language-typescript">// Good: Error handling in disposal
async dispose(): Promise&lt;void&gt; {
  const errors: Error[] = [];

  try {
    await this.flushLogs();
  } catch (error) {
    errors.push(error as Error);
  }

  try {
    await this.closeConnections();
  } catch (error) {
    errors.push(error as Error);
  }

  // Continue cleanup even if some steps fail
  this.cleanup();

  if (errors.length &gt; 0) {
    throw new AggregateError(errors, &apos;Disposal encountered errors&apos;);
  }
}
</codeblock>
    <section><title>3.5 Circular Dependency Resolution</title></section>
    <p>Circular dependencies occur when two or more services depend on each other, either directly or indirectly.</p>
    <section><title>Types of Circular Dependencies</title></section>
    <section><title>1. Direct Circular Dependency</title></section>
    <codeblock outputclass="language-typescript">// A depends on B
class ServiceA {
  constructor(private serviceB: ServiceB) {}
}

// B depends on A (circular!)
class ServiceB {
  constructor(private serviceA: ServiceA) {}
}

// Cannot be created:
// To create A, we need B
// To create B, we need A
// Infinite loop!
</codeblock>
    <section><title>2. Indirect Circular Dependency</title></section>
    <codeblock outputclass="language-typescript">// A ‚Üí B ‚Üí C ‚Üí A (circular chain)
class ServiceA {
  constructor(private serviceB: ServiceB) {}
}

class ServiceB {
  constructor(private serviceC: ServiceC) {}
}

class ServiceC {
  constructor(private serviceA: ServiceA) {}
}
</codeblock>
    <section><title>Detection in DI Container</title></section>
    <p>Our container detects circular dependencies:</p>
    <codeblock outputclass="language-typescript">export class DIContainer {
  private resolving = new Set&lt;string&gt;();

  async resolve&lt;T&gt;(key: string): Promise&lt;T&gt; {
    // Detect circular dependency
    if (this.resolving.has(key)) {
      const chain = Array.from(this.resolving).join(&apos; -&gt; &apos;) + &apos; -&gt; &apos; + key;
      throw new Error(`Circular dependency detected: ${chain}`);
    }

    try {
      this.resolving.add(key);
      // ... resolution logic ...
    } finally {
      this.resolving.delete(key);
    }
  }
}
</codeblock>
    <section><title>Breaking Circular Dependencies</title></section>
    <section><title>Strategy 1: Dependency Inversion</title></section>
    <p>Introduce an interface to break the cycle:</p>
    <codeblock outputclass="language-typescript">// Before: Circular dependency
class ConversationManager {
  constructor(private toolOrchestrator: ToolOrchestrator) {}
}

class ToolOrchestrator {
  constructor(private conversationManager: ConversationManager) {}
}

// After: Dependency inversion with interface
interface IConversationContext {
  getCurrentConversation(): Conversation;
  addMessage(message: Message): void;
}

class ConversationManager implements IConversationContext {
  constructor(private toolOrchestrator: ToolOrchestrator) {}

  getCurrentConversation(): Conversation {
    return this.currentConversation;
  }

  addMessage(message: Message): void {
    this.currentConversation.messages.push(message);
  }
}

// ToolOrchestrator depends on interface, not concrete class
class ToolOrchestrator {
  constructor(private context: IConversationContext) {}
}

// No circular dependency!
</codeblock>
    <section><title>Strategy 2: Lazy Injection</title></section>
    <p>Inject a factory function instead of the actual dependency:</p>
    <codeblock outputclass="language-typescript">// Before: Circular dependency
class ServiceA {
  constructor(private serviceB: ServiceB) {}
}

class ServiceB {
  constructor(private serviceA: ServiceA) {}
}

// After: Lazy injection with factory
class ServiceA {
  private _serviceB: ServiceB | null = null;

  constructor(private serviceBFactory: () =&gt; ServiceB) {}

  private get serviceB(): ServiceB {
    if (!this._serviceB) {
      this._serviceB = this.serviceBFactory();
    }
    return this._serviceB;
  }

  doSomething(): void {
    // serviceB is resolved lazily
    this.serviceB.execute();
  }
}

class ServiceB {
  constructor(private serviceA: ServiceA) {}
}

// Register with container
container.registerFactory(&apos;serviceA&apos;, (c) =&gt; {
  return new ServiceA(() =&gt; c.resolve(&apos;serviceB&apos;));
});

container.register(&apos;serviceB&apos;, ServiceB, {
  dependencies: [&apos;serviceA&apos;]
});
</codeblock>
    <section><title>Strategy 3: Event-Based Decoupling</title></section>
    <p>Use events instead of direct dependencies:</p>
    <codeblock outputclass="language-typescript">// Before: Circular dependency
class ConversationManager {
  constructor(private toolOrchestrator: ToolOrchestrator) {}

  async handleMessage(message: string): Promise&lt;void&gt; {
    const result = await this.toolOrchestrator.execute(message);
    // Process result
  }
}

class ToolOrchestrator {
  constructor(private conversationManager: ConversationManager) {}

  async execute(message: string): Promise&lt;void&gt; {
    // Need to update conversation
    await this.conversationManager.addMessage(message);
  }
}

// After: Event-based decoupling
class ConversationManager extends EventEmitter {
  constructor() {
    super();
  }

  async handleMessage(message: string): Promise&lt;void&gt; {
    this.emit(&apos;message&apos;, message);
  }
}

class ToolOrchestrator {
  constructor(private eventBus: EventEmitter) {
    // Listen to events instead of direct dependency
    this.eventBus.on(&apos;message&apos;, (message) =&gt; {
      this.execute(message);
    });
  }

  async execute(message: string): Promise&lt;void&gt; {
    // Emit event instead of calling conversationManager
    this.eventBus.emit(&apos;tool_result&apos;, result);
  }
}

// No circular dependency - both depend on EventEmitter
</codeblock>
    <section><title>Strategy 4: Split Responsibilities</title></section>
    <p>Sometimes circular dependencies indicate poor separation of concerns:</p>
    <codeblock outputclass="language-typescript">// Before: ConversationManager and ToolOrchestrator are too coupled
class ConversationManager {
  constructor(private toolOrchestrator: ToolOrchestrator) {}
}

class ToolOrchestrator {
  constructor(private conversationManager: ConversationManager) {}
}

// After: Extract shared logic into a third service
class MessageBus {
  private handlers = new Map&lt;string, Function[]&gt;();

  on(event: string, handler: Function): void {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, []);
    }
    this.handlers.get(event)!.push(handler);
  }

  emit(event: string, data: any): void {
    const handlers = this.handlers.get(event) || [];
    handlers.forEach(handler =&gt; handler(data));
  }
}

class ConversationManager {
  constructor(private messageBus: MessageBus) {
    this.messageBus.on(&apos;tool_result&apos;, (result) =&gt; {
      this.handleToolResult(result);
    });
  }

  async handleMessage(message: string): Promise&lt;void&gt; {
    this.messageBus.emit(&apos;message&apos;, message);
  }
}

class ToolOrchestrator {
  constructor(private messageBus: MessageBus) {
    this.messageBus.on(&apos;message&apos;, (message) =&gt; {
      this.execute(message);
    });
  }

  async execute(message: string): Promise&lt;void&gt; {
    const result = await this.runTools(message);
    this.messageBus.emit(&apos;tool_result&apos;, result);
  }
}

// Both depend on MessageBus, no circular dependency
</codeblock>
    <section><title>Real-World Example: ollama-code</title></section>
    <p>In ollama-code, we broke a circular dependency between <codeph>StreamingOrchestrator</codeph> and <codeph>ConversationManager</codeph>:</p>
    <codeblock outputclass="language-typescript">// Problem: StreamingOrchestrator needs ConversationManager to add messages
// ConversationManager needs StreamingOrchestrator to execute tools

// Solution: Dependency inversion with interface
interface IConversationContext {
  addMessage(role: &apos;user&apos; | &apos;assistant&apos; | &apos;system&apos;, content: string): void;
  getMessages(): Message[];
  getCurrentModel(): string;
}

class ConversationManager implements IConversationContext {
  private messages: Message[] = [];

  constructor(
    private router: IntelligentRouter,
    private logger: Logger
  ) {}

  addMessage(role: &apos;user&apos; | &apos;assistant&apos; | &apos;system&apos;, content: string): void {
    this.messages.push({ role, content, timestamp: Date.now() });
  }

  getMessages(): Message[] {
    return this.messages;
  }

  getCurrentModel(): string {
    return this.currentModel;
  }
}

class StreamingOrchestrator {
  constructor(
    private context: IConversationContext, // Interface, not concrete class
    private router: IntelligentRouter,
    private logger: Logger
  ) {}

  async stream(prompt: string, onChunk: (chunk: string) =&gt; void): Promise&lt;void&gt; {
    // Use context interface
    this.context.addMessage(&apos;user&apos;, prompt);

    // Stream response
    const messages = this.context.getMessages();
    // ... streaming logic ...
  }
}

// Register with container
container.register(&apos;conversationManager&apos;, ConversationManager, {
  singleton: true,
  dependencies: [&apos;router&apos;, &apos;logger&apos;]
});

container.register(&apos;streamingOrchestrator&apos;, StreamingOrchestrator, {
  singleton: true,
  dependencies: [&apos;conversationManager&apos;, &apos;router&apos;, &apos;logger&apos;]
  // conversationManager satisfies IConversationContext interface
});
</codeblock>
    <section><title>Prevention Strategies</title></section>
    <section><title>1. Design for Dependency Flow</title></section>
    <codeblock outputclass="language-typescript">// Good: Clear dependency hierarchy
// Layer 1 (Foundation)
Logger

// Layer 2 (Infrastructure)
ProviderManager ‚Üí Logger

// Layer 3 (Core Services)
Router ‚Üí ProviderManager, Logger
Fusion ‚Üí Router, Logger

// Layer 4 (Application Services)
ConversationManager ‚Üí Router, Logger
ToolOrchestrator ‚Üí Router, Logger

// Layer 5 (Orchestration)
App ‚Üí ConversationManager, ToolOrchestrator, Router, Logger

// Dependencies only flow downward (higher layers depend on lower layers)
</codeblock>
    <section><title>2. Use Mediator Pattern</title></section>
    <codeblock outputclass="language-typescript">// Mediator coordinates between components without creating cycles
class ApplicationMediator {
  constructor(
    private logger: Logger
  ) {}

  async handleUserMessage(message: string): Promise&lt;void&gt; {
    // Coordinate between services
    const conversation = await this.conversationManager.analyze(message);
    const tools = await this.toolOrchestrator.findTools(conversation.intent);
    const result = await this.router.execute(conversation, tools);

    return result;
  }

  setConversationManager(manager: ConversationManager): void {
    this.conversationManager = manager;
  }

  setToolOrchestrator(orchestrator: ToolOrchestrator): void {
    this.toolOrchestrator = orchestrator;
  }

  setRouter(router: IntelligentRouter): void {
    this.router = router;
  }
}

// Services depend on mediator, not each other
class ConversationManager {
  constructor(private mediator: ApplicationMediator) {}
}

class ToolOrchestrator {
  constructor(private mediator: ApplicationMediator) {}
}
</codeblock>
    <section><title>3.6 Testing with Dependency Injection</title></section>
    <p>One of the biggest benefits of DI is <b>testability</b>. Let&apos;s explore how to write comprehensive tests for a DI-based system.</p>
    <section><title>Testing Individual Services</title></section>
    <section><title>Without DI: Hard to Test</title></section>
    <codeblock outputclass="language-typescript">// Hard to test - creates real dependencies
export class ConversationManager {
  private router: IntelligentRouter;
  private logger: Logger;

  constructor() {
    // Hard-coded dependencies
    const providerManager = new ProviderManager();
    this.router = new IntelligentRouter(providerManager);
    this.logger = new Logger({ file: &apos;app.log&apos; });
  }

  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    this.logger.info(`Analyzing: ${prompt}`);
    const decision = await this.router.route({
      prompt,
      complexity: &apos;medium&apos;,
      priority: &apos;balanced&apos;
    });

    return { decision, confidence: 0.9 };
  }
}

// Test is forced to use real router and logger
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should analyze prompt&apos;, async () =&gt; {
    const manager = new ConversationManager();

    // This calls real AI providers! üí∏
    // Slow, expensive, unreliable
    const result = await manager.analyze(&apos;test prompt&apos;);

    expect(result).toBeDefined();
  });
});
</codeblock>
    <section><title>With DI: Easy to Test</title></section>
    <codeblock outputclass="language-typescript">// Easy to test - receives dependencies
export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger
  ) {}

  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    this.logger.info(`Analyzing: ${prompt}`);
    const decision = await this.router.route({
      prompt,
      complexity: &apos;medium&apos;,
      priority: &apos;balanced&apos;
    });

    return { decision, confidence: 0.9 };
  }
}

// Test injects mocks
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should analyze prompt&apos;, async () =&gt; {
    // Create mocks
    const mockRouter = {
      route: vi.fn().mockResolvedValue({
        providerId: &apos;test&apos;,
        model: &apos;test-model&apos;,
        reasoning: &apos;test&apos;,
        estimatedCost: 0,
        fallbacks: [],
        confidence: 1.0
      })
    };

    const mockLogger = {
      info: vi.fn(),
      error: vi.fn()
    };

    // Inject mocks
    const manager = new ConversationManager(
      mockRouter as any,
      mockLogger as any
    );

    // Test
    const result = await manager.analyze(&apos;test prompt&apos;);

    // Verify
    expect(mockLogger.info).toHaveBeenCalledWith(&apos;Analyzing: test prompt&apos;);
    expect(mockRouter.route).toHaveBeenCalledWith({
      prompt: &apos;test prompt&apos;,
      complexity: &apos;medium&apos;,
      priority: &apos;balanced&apos;
    });
    expect(result.confidence).toBe(0.9);
  });
});
</codeblock>
    <section><title>Testing with Test Container</title></section>
    <p>Create a test-specific container with mocked services:</p>
    <codeblock outputclass="language-typescript">/**
 * Create a test container with mocked services
 */
export function createTestContainer(): DIContainer {
  const container = new DIContainer();

  // Mock logger
  const mockLogger = {
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
    dispose: vi.fn()
  };
  container.registerInstance(&apos;logger&apos;, mockLogger);

  // Mock provider manager
  const mockProviderManager = {
    registerProvider: vi.fn(),
    getProvider: vi.fn(),
    getAllProviders: vi.fn().mockReturnValue(new Map()),
    setBudget: vi.fn(),
    trackUsage: vi.fn(),
    dispose: vi.fn()
  };
  container.registerInstance(&apos;providerManager&apos;, mockProviderManager);

  // Mock router
  const mockRouter = {
    route: vi.fn().mockResolvedValue({
      providerId: &apos;test&apos;,
      model: &apos;test-model&apos;,
      reasoning: &apos;test&apos;,
      estimatedCost: 0,
      fallbacks: [],
      confidence: 1.0
    }),
    executeWithFallback: vi.fn(),
    dispose: vi.fn()
  };
  container.registerInstance(&apos;router&apos;, mockRouter);

  return container;
}

// Use in tests
describe(&apos;ConversationManager&apos;, () =&gt; {
  let container: DIContainer;
  let manager: ConversationManager;

  beforeEach(async () =&gt; {
    container = createTestContainer();

    // Register the service under test
    container.register(&apos;conversationManager&apos;, ConversationManager, {
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });

    manager = await container.resolve(&apos;conversationManager&apos;);
  });

  afterEach(async () =&gt; {
    await container.dispose();
  });

  it(&apos;should analyze prompt&apos;, async () =&gt; {
    const result = await manager.analyze(&apos;test prompt&apos;);

    expect(result).toBeDefined();
    expect(result.confidence).toBe(0.9);
  });
});
</codeblock>
    <section><title>Testing Service Registration</title></section>
    <p>Test that services are registered correctly:</p>
    <codeblock outputclass="language-typescript">describe(&apos;ServiceRegistry&apos;, () =&gt; {
  let container: DIContainer;

  beforeEach(() =&gt; {
    container = new DIContainer();
  });

  afterEach(async () =&gt; {
    await container.dispose();
  });

  it(&apos;should register core services&apos;, () =&gt; {
    ServiceRegistry.registerCoreServices(container);

    expect(container.has(&apos;logger&apos;)).toBe(true);
    expect(container.has(&apos;providerManager&apos;)).toBe(true);
    expect(container.has(&apos;router&apos;)).toBe(true);
    expect(container.has(&apos;fusion&apos;)).toBe(true);
  });

  it(&apos;should resolve logger&apos;, async () =&gt; {
    ServiceRegistry.registerCoreServices(container);

    const logger = await container.resolve&lt;Logger&gt;(&apos;logger&apos;);

    expect(logger).toBeDefined();
    expect(typeof logger.info).toBe(&apos;function&apos;);
  });

  it(&apos;should resolve router with dependencies&apos;, async () =&gt; {
    ServiceRegistry.registerCoreServices(container);

    const router = await container.resolve&lt;IntelligentRouter&gt;(&apos;router&apos;);

    expect(router).toBeDefined();
    // Router should have providerManager and logger injected
  });

  it(&apos;should create singletons&apos;, async () =&gt; {
    ServiceRegistry.registerCoreServices(container);

    const logger1 = await container.resolve&lt;Logger&gt;(&apos;logger&apos;);
    const logger2 = await container.resolve&lt;Logger&gt;(&apos;logger&apos;);

    // Same instance
    expect(logger1).toBe(logger2);
  });
});
</codeblock>
    <section><title>Integration Testing</title></section>
    <p>Test multiple services working together:</p>
    <codeblock outputclass="language-typescript">describe(&apos;Integration: Conversation + Router&apos;, () =&gt; {
  let container: DIContainer;

  beforeEach(async () =&gt; {
    container = new DIContainer();

    // Register real services (but with mocked providers)
    ServiceRegistry.registerCoreServices(container);

    // Mock AI providers to avoid real API calls
    const mockProvider = {
      getName: () =&gt; &apos;mock&apos;,
      initialize: vi.fn(),
      complete: vi.fn().mockResolvedValue({
        content: &apos;Mocked response&apos;,
        tokensUsed: { prompt: 10, completion: 20, total: 30 }
      }),
      completeStream: vi.fn(),
      listModels: vi.fn(),
      calculateCost: () =&gt; 0,
      testConnection: vi.fn().mockResolvedValue(true),
      performHealthCheck: vi.fn(),
      getHealth: () =&gt; ({ status: &apos;healthy&apos;, lastCheck: Date.now() }),
      getMetrics: () =&gt; ({
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalTokensUsed: 0,
        totalCost: 0,
        averageResponseTime: 0
      }),
      dispose: vi.fn()
    };

    const providerManager = await container.resolve&lt;ProviderManager&gt;(&apos;providerManager&apos;);
    await providerManager.registerProvider(&apos;mock&apos;, mockProvider as any);

    // Register conversation manager
    container.register(&apos;conversationManager&apos;, ConversationManager, {
      dependencies: [&apos;router&apos;, &apos;logger&apos;]
    });
  });

  afterEach(async () =&gt; {
    await container.dispose();
  });

  it(&apos;should analyze prompt using router&apos;, async () =&gt; {
    const manager = await container.resolve&lt;ConversationManager&gt;(&apos;conversationManager&apos;);

    const result = await manager.analyze(&apos;test prompt&apos;);

    expect(result).toBeDefined();
    expect(result.decision).toBeDefined();
    expect(result.decision.providerId).toBe(&apos;mock&apos;);
  });
});
</codeblock>
    <section><title>Testing Lifecycle Hooks</title></section>
    <codeblock outputclass="language-typescript">describe(&apos;Service Lifecycle&apos;, () =&gt; {
  it(&apos;should call onInit hook&apos;, async () =&gt; {
    const container = new DIContainer();
    const initSpy = vi.fn();

    container.register(&apos;test&apos;, Logger, {
      lifecycle: {
        onInit: initSpy
      }
    });

    await container.resolve(&apos;test&apos;);

    expect(initSpy).toHaveBeenCalledTimes(1);
  });

  it(&apos;should call onDispose hook&apos;, async () =&gt; {
    const container = new DIContainer();
    const disposeSpy = vi.fn();

    container.register(&apos;test&apos;, Logger, {
      lifecycle: {
        onDispose: disposeSpy
      }
    });

    await container.resolve(&apos;test&apos;);
    await container.dispose();

    expect(disposeSpy).toHaveBeenCalledTimes(1);
  });

  it(&apos;should dispose in reverse order&apos;, async () =&gt; {
    const container = new DIContainer();
    const order: string[] = [];

    container.register(&apos;logger&apos;, Logger, {
      lifecycle: {
        onDispose: () =&gt; order.push(&apos;logger&apos;)
      }
    });

    container.register(&apos;manager&apos;, ProviderManager, {
      dependencies: [&apos;logger&apos;],
      lifecycle: {
        onDispose: () =&gt; order.push(&apos;manager&apos;)
      }
    });

    container.register(&apos;router&apos;, IntelligentRouter, {
      dependencies: [&apos;manager&apos;, &apos;logger&apos;],
      lifecycle: {
        onDispose: () =&gt; order.push(&apos;router&apos;)
      }
    });

    await container.resolve(&apos;router&apos;);
    await container.dispose();

    // Should dispose in reverse order
    expect(order).toEqual([&apos;router&apos;, &apos;manager&apos;, &apos;logger&apos;]);
  });
});
</codeblock>
    <section><title>Testing Error Scenarios</title></section>
    <codeblock outputclass="language-typescript">describe(&apos;DI Container Error Handling&apos;, () =&gt; {
  let container: DIContainer;

  beforeEach(() =&gt; {
    container = new DIContainer();
  });

  it(&apos;should throw on unregistered service&apos;, async () =&gt; {
    await expect(
      container.resolve(&apos;nonexistent&apos;)
    ).rejects.toThrow(&quot;Service &apos;nonexistent&apos; is not registered&quot;);
  });

  it(&apos;should detect circular dependencies&apos;, async () =&gt; {
    // Register circular dependency
    container.registerFactory(&apos;serviceA&apos;, async (c) =&gt; {
      const b = await c.resolve(&apos;serviceB&apos;);
      return { b };
    });

    container.registerFactory(&apos;serviceB&apos;, async (c) =&gt; {
      const a = await c.resolve(&apos;serviceA&apos;);
      return { a };
    });

    await expect(
      container.resolve(&apos;serviceA&apos;)
    ).rejects.toThrow(/Circular dependency detected/);
  });

  it(&apos;should handle initialization errors&apos;, async () =&gt; {
    container.registerFactory(&apos;failing&apos;, () =&gt; {
      throw new Error(&apos;Initialization failed&apos;);
    });

    await expect(
      container.resolve(&apos;failing&apos;)
    ).rejects.toThrow(&apos;Initialization failed&apos;);
  });

  it(&apos;should continue disposal on error&apos;, async () =&gt; {
    const successSpy = vi.fn();

    container.registerInstance(&apos;failing&apos;, {
      dispose: () =&gt; { throw new Error(&apos;Dispose failed&apos;); }
    });

    container.registerInstance(&apos;success&apos;, {
      dispose: successSpy
    });

    await container.resolve(&apos;failing&apos;);
    await container.resolve(&apos;success&apos;);

    // Should not throw, but collect errors
    await expect(container.dispose()).rejects.toThrow(AggregateError);

    // Success should still be disposed
    expect(successSpy).toHaveBeenCalled();
  });
});
</codeblock>
    <section><title>Mock Factories</title></section>
    <p>Create reusable mock factories:</p>
    <codeblock outputclass="language-typescript">/**
 * Mock factory utilities
 */
export class MockFactory {
  /**
   * Create mock logger
   */
  static createLogger(): Logger {
    return {
      info: vi.fn(),
      error: vi.fn(),
      warn: vi.fn(),
      debug: vi.fn(),
      flush: vi.fn(),
      dispose: vi.fn()
    } as any;
  }

  /**
   * Create mock router
   */
  static createRouter(overrides: Partial&lt;IntelligentRouter&gt; = {}): IntelligentRouter {
    return {
      route: vi.fn().mockResolvedValue({
        providerId: &apos;test&apos;,
        model: &apos;test-model&apos;,
        reasoning: &apos;test&apos;,
        estimatedCost: 0,
        fallbacks: [],
        confidence: 1.0
      }),
      executeWithFallback: vi.fn(),
      registerStrategy: vi.fn(),
      dispose: vi.fn(),
      ...overrides
    } as any;
  }

  /**
   * Create mock provider
   */
  static createProvider(
    name: string = &apos;test&apos;,
    overrides: Partial&lt;BaseAIProvider&gt; = {}
  ): BaseAIProvider {
    return {
      getName: () =&gt; name,
      initialize: vi.fn(),
      complete: vi.fn().mockResolvedValue({
        content: &apos;Test response&apos;,
        tokensUsed: { prompt: 10, completion: 20, total: 30 }
      }),
      completeStream: vi.fn(),
      listModels: vi.fn().mockResolvedValue([
        { id: &apos;test-model&apos;, name: &apos;Test Model&apos;, contextWindow: 4096 }
      ]),
      calculateCost: () =&gt; 0,
      testConnection: vi.fn().mockResolvedValue(true),
      performHealthCheck: vi.fn(),
      getHealth: () =&gt; ({ status: &apos;healthy&apos;, lastCheck: Date.now() }),
      getMetrics: () =&gt; ({
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalTokensUsed: 0,
        totalCost: 0,
        averageResponseTime: 0
      }),
      dispose: vi.fn(),
      ...overrides
    } as any;
  }

  /**
   * Create mock provider manager
   */
  static createProviderManager(): ProviderManager {
    const providers = new Map&lt;string, BaseAIProvider&gt;();

    return {
      registerProvider: vi.fn((id, provider) =&gt; {
        providers.set(id, provider);
      }),
      getProvider: vi.fn((id) =&gt; providers.get(id)),
      getAllProviders: vi.fn(() =&gt; providers),
      removeProvider: vi.fn((id) =&gt; providers.delete(id)),
      setBudget: vi.fn(),
      getBudget: vi.fn(),
      trackUsage: vi.fn(),
      getUsageStats: vi.fn(() =&gt; ({
        totalRequests: 0,
        successfulRequests: 0,
        failedRequests: 0,
        totalTokensUsed: 0,
        totalCost: 0,
        averageResponseTime: 0,
        dailyUsage: new Map(),
        monthlyUsage: new Map()
      })),
      dispose: vi.fn()
    } as any;
  }
}

// Usage in tests
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should use mocked router&apos;, async () =&gt; {
    const router = MockFactory.createRouter();
    const logger = MockFactory.createLogger();

    const manager = new ConversationManager(router, logger);

    await manager.analyze(&apos;test&apos;);

    expect(router.route).toHaveBeenCalled();
  });
});
</codeblock>
    <section><title>Test Coverage Best Practices</title></section>
    <codeblock outputclass="language-typescript">describe(&apos;ConversationManager - Comprehensive Coverage&apos;, () =&gt; {
  let router: IntelligentRouter;
  let logger: Logger;
  let manager: ConversationManager;

  beforeEach(() =&gt; {
    router = MockFactory.createRouter();
    logger = MockFactory.createLogger();
    manager = new ConversationManager(router, logger);
  });

  describe(&apos;analyze()&apos;, () =&gt; {
    it(&apos;should analyze simple prompts&apos;, async () =&gt; {
      const result = await manager.analyze(&apos;simple test&apos;);

      expect(result).toBeDefined();
      expect(logger.info).toHaveBeenCalled();
    });

    it(&apos;should handle complex prompts&apos;, async () =&gt; {
      const longPrompt = &apos;a&apos;.repeat(5000);

      const result = await manager.analyze(longPrompt);

      expect(result).toBeDefined();
    });

    it(&apos;should handle router errors&apos;, async () =&gt; {
      (router.route as any).mockRejectedValue(new Error(&apos;Router failed&apos;));

      await expect(
        manager.analyze(&apos;test&apos;)
      ).rejects.toThrow(&apos;Router failed&apos;);

      expect(logger.error).toHaveBeenCalled();
    });

    it(&apos;should log analysis&apos;, async () =&gt; {
      await manager.analyze(&apos;test prompt&apos;);

      expect(logger.info).toHaveBeenCalledWith(&apos;Analyzing: test prompt&apos;);
    });

    it(&apos;should return correct confidence&apos;, async () =&gt; {
      const result = await manager.analyze(&apos;test&apos;);

      expect(result.confidence).toBe(0.9);
    });
  });

  describe(&apos;edge cases&apos;, () =&gt; {
    it(&apos;should handle empty prompts&apos;, async () =&gt; {
      await expect(
        manager.analyze(&apos;&apos;)
      ).rejects.toThrow(&apos;Prompt cannot be empty&apos;);
    });

    it(&apos;should handle null prompts&apos;, async () =&gt; {
      await expect(
        manager.analyze(null as any)
      ).rejects.toThrow(&apos;Prompt is required&apos;);
    });

    it(&apos;should handle very long prompts&apos;, async () =&gt; {
      const longPrompt = &apos;a&apos;.repeat(100000);

      await expect(
        manager.analyze(longPrompt)
      ).rejects.toThrow(&apos;Prompt exceeds maximum length&apos;);
    });
  });
});
</codeblock>
    <section><title>3.7 Best Practices</title></section>
    <p>Let&apos;s consolidate the best practices for using Dependency Injection in production AI systems.</p>
    <section><title>1. Service Registration</title></section>
    <p><b>‚úÖ Do: Register services at application startup</b></p>
    <codeblock outputclass="language-typescript">async function bootstrap() {
  const container = new DIContainer();

  // Register all services before resolving
  await ServiceRegistry.registerAll(container);

  // Now resolve
  const app = await container.resolve&lt;OllamaCodeApp&gt;(&apos;app&apos;);

  return app;
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Register services on-demand</b></p>
    <codeblock outputclass="language-typescript">// Bad: Scattered registration
async function someFunction() {
  if (!container.has(&apos;logger&apos;)) {
    container.register(&apos;logger&apos;, Logger);
  }
  // Hard to track what&apos;s registered when
}
</codeblock>
    <section><title>2. Dependency Declaration</title></section>
    <p><b>‚úÖ Do: Declare dependencies explicitly in constructor</b></p>
    <codeblock outputclass="language-typescript">export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger,
    private config: Config
  ) {
    // Dependencies clearly visible
  }
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Use service locator pattern</b></p>
    <codeblock outputclass="language-typescript">// Bad: Hidden dependencies
export class ConversationManager {
  constructor(private container: DIContainer) {}

  async analyze(prompt: string) {
    // Dependencies hidden in implementation
    const router = await this.container.resolve(&apos;router&apos;);
    const logger = await this.container.resolve(&apos;logger&apos;);
    // ...
  }
}
</codeblock>
    <section><title>3. Service Lifetime</title></section>
    <p><b>‚úÖ Do: Use singletons for stateful services</b></p>
    <codeblock outputclass="language-typescript">// Singleton: shared state across application
container.register(&apos;logger&apos;, Logger, { singleton: true });
container.register(&apos;providerManager&apos;, ProviderManager, { singleton: true });
container.register(&apos;router&apos;, IntelligentRouter, { singleton: true });
</codeblock>
    <p><b>‚úÖ Do: Use transient for stateless services</b></p>
    <codeblock outputclass="language-typescript">// Transient: new instance each time
container.register(&apos;requestAnalyzer&apos;, RequestAnalyzer, { singleton: false });
container.register(&apos;tempProcessor&apos;, TempProcessor, { singleton: false });
</codeblock>
    <p><b>‚ùå Don&apos;t: Make everything a singleton</b></p>
    <codeblock outputclass="language-typescript">// Bad: Singleton for stateless service
container.register(&apos;requestAnalyzer&apos;, RequestAnalyzer, { singleton: true });
// Can cause concurrency issues if service has mutable state
</codeblock>
    <section><title>4. Testing</title></section>
    <p><b>‚úÖ Do: Inject dependencies in constructor</b></p>
    <codeblock outputclass="language-typescript">// Easy to test
export class ServiceA {
  constructor(private serviceB: ServiceB) {}
}

// Test with mock
const mock = { /* ... */ };
const service = new ServiceA(mock);
</codeblock>
    <p><b>‚úÖ Do: Create test-specific containers</b></p>
    <codeblock outputclass="language-typescript">function createTestContainer(): DIContainer {
  const container = new DIContainer();
  // Register mocks
  container.registerInstance(&apos;logger&apos;, mockLogger);
  container.registerInstance(&apos;router&apos;, mockRouter);
  return container;
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Use real services in unit tests</b></p>
    <codeblock outputclass="language-typescript">// Bad: Uses real AI providers in tests
describe(&apos;ConversationManager&apos;, () =&gt; {
  it(&apos;should analyze&apos;, async () =&gt; {
    const container = new DIContainer();
    await ServiceRegistry.registerAll(container); // Real providers!

    const manager = await container.resolve(&apos;conversationManager&apos;);
    await manager.analyze(&apos;test&apos;); // Calls real APIs! üí∏
  });
});
</codeblock>
    <section><title>5. Resource Disposal</title></section>
    <p><b>‚úÖ Do: Implement IDisposable for resources</b></p>
    <codeblock outputclass="language-typescript">export class ProviderManager implements IDisposable {
  async dispose(): Promise&lt;void&gt; {
    // Clean up resources
    await this.saveStats();
    await this.closeConnections();
  }
}
</codeblock>
    <p><b>‚úÖ Do: Dispose container on shutdown</b></p>
    <codeblock outputclass="language-typescript">async function main() {
  const container = new DIContainer();
  let app;

  try {
    app = await bootstrap();
    await app.run();
  } finally {
    await container.dispose(); // Clean up all singletons
  }
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Forget to dispose</b></p>
    <codeblock outputclass="language-typescript">// Bad: Resources leak
async function main() {
  const app = await bootstrap();
  await app.run();
  // Container never disposed - leaks!
}
</codeblock>
    <section><title>6. Circular Dependencies</title></section>
    <p><b>‚úÖ Do: Design for dependency flow</b></p>
    <codeblock outputclass="language-typescript">// Good: Clear hierarchy
// Logger (foundation)
// ‚Üí ProviderManager (infrastructure)
//   ‚Üí Router (core service)
//     ‚Üí ConversationManager (application service)
//       ‚Üí App (orchestration)
</codeblock>
    <p><b>‚úÖ Do: Use interfaces to break cycles</b></p>
    <codeblock outputclass="language-typescript">interface IConversationContext {
  addMessage(message: Message): void;
  getMessages(): Message[];
}

class ConversationManager implements IConversationContext {
  constructor(private toolOrchestrator: ToolOrchestrator) {}
}

class ToolOrchestrator {
  constructor(private context: IConversationContext) {}
  // Depends on interface, not concrete class
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Create circular dependencies</b></p>
    <codeblock outputclass="language-typescript">// Bad: A depends on B, B depends on A
class ServiceA {
  constructor(private serviceB: ServiceB) {}
}

class ServiceB {
  constructor(private serviceA: ServiceA) {}
}
</codeblock>
    <section><title>7. Configuration</title></section>
    <p><b>‚úÖ Do: Use environment-based configuration</b></p>
    <codeblock outputclass="language-typescript">container.registerFactory(&apos;logger&apos;, () =&gt; {
  return new Logger({
    level: process.env.LOG_LEVEL || &apos;info&apos;,
    file: process.env.LOG_FILE || &apos;app.log&apos;
  });
});
</codeblock>
    <p><b>‚úÖ Do: Validate configuration at startup</b></p>
    <codeblock outputclass="language-typescript">async function bootstrap() {
  // Validate required configuration
  if (!process.env.OPENAI_API_KEY &amp;&amp; !process.env.OLLAMA_BASE_URL) {
    throw new Error(&apos;At least one AI provider must be configured&apos;);
  }

  const container = new DIContainer();
  await ServiceRegistry.registerAll(container);

  return container;
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Hardcode configuration</b></p>
    <codeblock outputclass="language-typescript">// Bad: Hardcoded values
container.registerFactory(&apos;logger&apos;, () =&gt; {
  return new Logger({
    level: &apos;debug&apos;, // Should be configurable
    file: &apos;/var/log/app.log&apos; // Won&apos;t work on all systems
  });
});
</codeblock>
    <section><title>8. Error Handling</title></section>
    <p><b>‚úÖ Do: Handle initialization errors gracefully</b></p>
    <codeblock outputclass="language-typescript">async function bootstrap() {
  const container = new DIContainer();

  try {
    await ServiceRegistry.registerAll(container);
  } catch (error) {
    console.error(&apos;Service registration failed:&apos;, error);
    await container.dispose(); // Clean up partial initialization
    throw error;
  }

  return container;
}
</codeblock>
    <p><b>‚úÖ Do: Provide helpful error messages</b></p>
    <codeblock outputclass="language-typescript">export class DIContainer {
  async resolve&lt;T&gt;(key: string): Promise&lt;T&gt; {
    if (!this.services.has(key)) {
      const available = Array.from(this.services.keys()).join(&apos;, &apos;);
      throw new Error(
        `Service &apos;${key}&apos; is not registered. ` +
        `Available services: ${available}`
      );
    }
    // ...
  }
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Swallow errors</b></p>
    <codeblock outputclass="language-typescript">// Bad: Silent failure
async function bootstrap() {
  const container = new DIContainer();

  try {
    await ServiceRegistry.registerAll(container);
  } catch (error) {
    // Error ignored!
  }

  return container; // Partially initialized
}
</codeblock>
    <section><title>9. Scoping</title></section>
    <p><b>‚úÖ Do: Use child containers for scoped lifetimes</b></p>
    <codeblock outputclass="language-typescript">// Request-scoped container
async function handleRequest(req: Request) {
  const requestScope = container.createScope();

  // Register request-specific services
  requestScope.registerInstance(&apos;request&apos;, req);
  requestScope.registerInstance(&apos;user&apos;, req.user);

  try {
    const handler = await requestScope.resolve(&apos;requestHandler&apos;);
    return await handler.handle();
  } finally {
    await requestScope.dispose(); // Clean up request scope
  }
}
</codeblock>
    <p><b>‚ùå Don&apos;t: Use singletons for request-scoped data</b></p>
    <codeblock outputclass="language-typescript">// Bad: Shared mutable state across requests
container.register(&apos;requestContext&apos;, RequestContext, { singleton: true });
// Multiple requests will overwrite each other&apos;s data!
</codeblock>
    <section><title>10. Documentation</title></section>
    <p><b>‚úÖ Do: Document service dependencies</b></p>
    <codeblock outputclass="language-typescript">/**
 * Manages AI provider conversations
 *
 * @param router - Intelligent router for provider selection
 * @param logger - Application logger
 * @param config - Application configuration
 */
export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger,
    private config: Config
  ) {}
}
</codeblock>
    <p><b>‚úÖ Do: Document service lifetime</b></p>
    <codeblock outputclass="language-typescript">// Register logger as singleton - shared across application
container.register(&apos;logger&apos;, Logger, { singleton: true });

// Register analyzer as transient - new instance per use
container.register(&apos;analyzer&apos;, Analyzer, { singleton: false });
</codeblock>
    <section><title>Summary and Key Takeaways</title></section>
    <p>In this chapter, we&apos;ve built a comprehensive Dependency Injection system for AI applications. Let&apos;s recap:</p>
    <section><title>Core Concepts</title></section>
    <ol>
      <li>
        <b>Dependency Injection</b>
        - Pass dependencies to objects instead of creating them internally
      </li>
      <li>
        <b>DI Container</b>
        - Centralized registry that manages service creation and lifetime
      </li>
      <li>
        <b>Service Lifetime</b>
        - Singleton (shared), Transient (new instance), Scoped (per request)
      </li>
      <li>
        <b>IDisposable Pattern</b>
        - Standard way to release resources
      </li>
      <li>
        <b>Circular Dependencies</b>
        - When services depend on each other (should be avoided)
      </li>
    </ol>
    <section><title>Architecture Components</title></section>
    <ol>
      <li>
        <b>DIContainer</b>
        - Core container implementation
      </li>
      <li>
        Service registration
      </li>
      <li>
        Dependency resolution
      </li>
      <li>
        Lifecycle management
      </li>
      <li>
        <p>Circular dependency detection</p>
      </li>
      <li>
        <p><b>ServiceRegistry</b> - Centralized service configuration</p>
      </li>
      <li>
        registerCoreServices()
      </li>
      <li>
        registerProviders()
      </li>
      <li>
        registerConversationServices()
      </li>
      <li>
        registerToolServices()
      </li>
      <li>
        <p>registerVCSServices()</p>
      </li>
      <li>
        <p><b>IDisposable</b> - Resource cleanup interface</p>
      </li>
      <li>
        dispose() method
      </li>
      <li>
        Integration with container
      </li>
      <li>
        Reverse-order disposal
      </li>
    </ol>
    <section><title>Benefits of DI</title></section>
    <p>‚úÖ <b>Testability</b> - Easy to mock dependencies
‚úÖ <b>Flexibility</b> - Swap implementations without changing code
‚úÖ <b>Maintainability</b> - Clear dependency relationships
‚úÖ <b>Lifecycle Management</b> - Automatic resource cleanup
‚úÖ <b>Reduced Coupling</b> - Components don&apos;t create dependencies</p>
    <section><title>Common Pitfalls to Avoid</title></section>
    <p>‚ö†Ô∏è <b>Don&apos;t</b>: Use service locator pattern (hides dependencies)
‚ö†Ô∏è <b>Don&apos;t</b>: Create circular dependencies
‚ö†Ô∏è <b>Don&apos;t</b>: Forget to dispose resources
‚ö†Ô∏è <b>Don&apos;t</b>: Make everything a singleton
‚ö†Ô∏è <b>Don&apos;t</b>: Use real services in unit tests</p>
    <section><title>Production Checklist</title></section>
    <p>Before deploying:</p>
    <ul>
      <li>
        [ ] All services registered at startup
      </li>
      <li>
        [ ] Dependencies declared explicitly in constructors
      </li>
      <li>
        [ ] Appropriate service lifetimes (singleton vs transient)
      </li>
      <li>
        [ ] IDisposable implemented for all resources
      </li>
      <li>
        [ ] Container disposed on shutdown
      </li>
      <li>
        [ ] No circular dependencies
      </li>
      <li>
        [ ] Configuration externalized
      </li>
      <li>
        [ ] Comprehensive tests with mocks
      </li>
      <li>
        [ ] Error handling in initialization
      </li>
      <li>
        [ ] Helpful error messages
      </li>
    </ul>
    <section><title>Exercises</title></section>
    <p>Now apply what you&apos;ve learned with hands-on exercises.</p>
    <section><title>Exercise 1: Implement a Custom Service (60 minutes)</title></section>
    <p><b>Goal</b>: Create a caching service with DI</p>
    <p><b>Requirements</b>:
1. Implement <codeph>CacheService</codeph> with IDisposable
2. Register with DI container
3. Inject into existing services
4. Write comprehensive tests</p>
    <p><b>Starter Code</b>:</p>
    <codeblock outputclass="language-typescript">export interface CacheEntry&lt;T&gt; {
  value: T;
  expiresAt: number;
}

export class CacheService implements IDisposable {
  private cache = new Map&lt;string, CacheEntry&lt;any&gt;&gt;();
  private cleanupInterval: NodeJS.Timeout | null = null;

  constructor(
    private logger: Logger,
    private ttlMs: number = 300000 // 5 minutes default
  ) {
    // TODO: Start cleanup interval
  }

  get&lt;T&gt;(key: string): T | null {
    // TODO: Implement get with expiration check
    return null;
  }

  set&lt;T&gt;(key: string, value: T, ttlMs?: number): void {
    // TODO: Implement set with TTL
  }

  delete(key: string): boolean {
    // TODO: Implement delete
    return false;
  }

  clear(): void {
    // TODO: Implement clear
  }

  private cleanup(): void {
    // TODO: Remove expired entries
  }

  async dispose(): Promise&lt;void&gt; {
    // TODO: Stop cleanup interval, clear cache
  }
}

// Register with container
container.register(&apos;cache&apos;, CacheService, {
  singleton: true,
  dependencies: [&apos;logger&apos;],
  lifecycle: {
    onDispose: async (cache) =&gt; {
      await cache.dispose();
    }
  }
});

// Use in ConversationManager
export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger,
    private cache: CacheService // Injected dependency
  ) {}

  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    // Check cache first
    const cached = this.cache.get&lt;Analysis&gt;(`analysis:${prompt}`);
    if (cached) {
      this.logger.info(&apos;Cache hit&apos;);
      return cached;
    }

    // Compute and cache
    const result = await this.computeAnalysis(prompt);
    this.cache.set(`analysis:${prompt}`, result);

    return result;
  }
}
</codeblock>
    <p><b>Solution</b>: See <codeph>book/exercises/chapter-03/exercise-01-solution.ts</codeph></p>
    <section><title>Exercise 2: Fix Circular Dependencies (90 minutes)</title></section>
    <p><b>Goal</b>: Refactor code with circular dependencies</p>
    <p><b>Scenario</b>: You have this circular dependency:</p>
    <codeblock outputclass="language-typescript">class EmailService {
  constructor(private notificationService: NotificationService) {}

  async sendEmail(to: string, subject: string, body: string): Promise&lt;void&gt; {
    await this.send(to, subject, body);
    await this.notificationService.recordSent(&apos;email&apos;, to);
  }
}

class NotificationService {
  constructor(private emailService: EmailService) {}

  async notify(user: User, message: string): Promise&lt;void&gt; {
    await this.emailService.sendEmail(user.email, &apos;Notification&apos;, message);
    this.recordSent(&apos;notification&apos;, user.id);
  }

  recordSent(type: string, recipient: string): void {
    // Record in database
  }
}
</codeblock>
    <p><b>Task</b>: Break the circular dependency using one of these strategies:
1. Dependency Inversion (interfaces)
2. Event-based decoupling
3. Extract shared service</p>
    <p><b>Solution</b>: See <codeph>book/exercises/chapter-03/exercise-02-solution.ts</codeph></p>
    <section><title>Exercise 3: Build a Test Container Factory (60 minutes)</title></section>
    <p><b>Goal</b>: Create comprehensive test utilities</p>
    <p><b>Requirements</b>:
1. Create <codeph>TestContainerFactory</codeph> class
2. Support different test scenarios (unit, integration, e2e)
3. Provide mock factories for all core services
4. Include snapshot/restore functionality</p>
    <p><b>Starter Code</b>:</p>
    <codeblock outputclass="language-typescript">export class TestContainerFactory {
  /**
   * Create container for unit tests (all mocks)
   */
  static createUnit(): DIContainer {
    // TODO: Register all mocked services
    return container;
  }

  /**
   * Create container for integration tests (some real services)
   */
  static createIntegration(): DIContainer {
    // TODO: Mix of real and mocked services
    return container;
  }

  /**
   * Create container for E2E tests (all real services)
   */
  static async createE2E(): Promise&lt;DIContainer&gt; {
    // TODO: Register real services with test configuration
    return container;
  }

  /**
   * Create snapshot of container state
   */
  static snapshot(container: DIContainer): ContainerSnapshot {
    // TODO: Capture current state
    return snapshot;
  }

  /**
   * Restore container from snapshot
   */
  static restore(container: DIContainer, snapshot: ContainerSnapshot): void {
    // TODO: Restore state
  }
}
</codeblock>
    <p><b>Solution</b>: See <codeph>book/exercises/chapter-03/exercise-03-solution.ts</codeph></p>
    <section><title>Exercise 4: Implement Service Decorators (120 minutes)</title></section>
    <p><b>Goal</b>: Add cross-cutting concerns with decorators</p>
    <p><b>Task</b>: Implement decorators for:
1. Logging (log method entry/exit)
2. Timing (measure execution time)
3. Caching (cache method results)
4. Retry (retry failed operations)</p>
    <p><b>Starter Code</b>:</p>
    <codeblock outputclass="language-typescript">/**
 * Log method calls
 */
export function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = async function (...args: any[]) {
    const logger = this.logger || console;
    logger.info(`Calling ${propertyKey}`, { args });

    try {
      const result = await originalMethod.apply(this, args);
      logger.info(`${propertyKey} succeeded`, { result });
      return result;
    } catch (error) {
      logger.error(`${propertyKey} failed`, error);
      throw error;
    }
  };

  return descriptor;
}

/**
 * Measure execution time
 */
export function Timed(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  // TODO: Implement timing decorator
  return descriptor;
}

/**
 * Cache method results
 */
export function Cached(ttlMs: number = 300000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // TODO: Implement caching decorator
    return descriptor;
  };
}

/**
 * Retry failed operations
 */
export function Retry(maxAttempts: number = 3, delayMs: number = 1000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // TODO: Implement retry decorator
    return descriptor;
  };
}

// Usage
export class ConversationManager {
  constructor(
    private router: IntelligentRouter,
    private logger: Logger
  ) {}

  @Log
  @Timed
  @Cached(60000) // Cache for 1 minute
  async analyze(prompt: string): Promise&lt;Analysis&gt; {
    return await this.computeAnalysis(prompt);
  }

  @Retry(3, 2000)
  async computeAnalysis(prompt: string): Promise&lt;Analysis&gt; {
    // May fail, will be retried
  }
}
</codeblock>
    <p><b>Solution</b>: See <codeph>book/exercises/chapter-03/exercise-04-solution.ts</codeph></p>
    <section><title>Exercise 5: Performance Benchmarking (90 minutes)</title></section>
    <p><b>Goal</b>: Measure DI container overhead</p>
    <p><b>Task</b>: Create benchmarks to measure:
1. Registration time
2. Resolution time (first vs cached)
3. Disposal time
4. Memory usage</p>
    <p><b>Starter Code</b>:</p>
    <codeblock outputclass="language-typescript">export class DIBenchmark {
  async benchmarkRegistration(serviceCount: number): Promise&lt;BenchmarkResult&gt; {
    const container = new DIContainer();

    const start = performance.now();

    for (let i = 0; i &lt; serviceCount; i++) {
      container.register(`service${i}`, Logger);
    }

    const duration = performance.now() - start;

    return {
      operation: &apos;registration&apos;,
      count: serviceCount,
      duration,
      opsPerSecond: serviceCount / (duration / 1000)
    };
  }

  async benchmarkResolution(serviceCount: number): Promise&lt;BenchmarkResult&gt; {
    // TODO: Benchmark resolution time
    return result;
  }

  async benchmarkCachedResolution(iterations: number): Promise&lt;BenchmarkResult&gt; {
    // TODO: Benchmark cached singleton resolution
    return result;
  }

  async benchmarkDisposal(serviceCount: number): Promise&lt;BenchmarkResult&gt; {
    // TODO: Benchmark disposal time
    return result;
  }

  async benchmarkMemory(): Promise&lt;MemoryBenchmark&gt; {
    // TODO: Measure memory usage
    return result;
  }

  generateReport(results: BenchmarkResult[]): string {
    // TODO: Generate markdown report
    return report;
  }
}
</codeblock>
    <p><b>Bonus</b>: Compare DI overhead vs manual dependency management</p>
    <p><b>Solution</b>: See <codeph>book/exercises/chapter-03/exercise-05-solution.ts</codeph></p>
    <section><title>Chapter 3 Complete!</title></section>
    <p>Congratulations! You now have a deep understanding of Dependency Injection for AI systems, including:</p>
    <p>‚úÖ Why DI matters and when to use it
‚úÖ Building a production-ready DI container
‚úÖ Service registry patterns
‚úÖ IDisposable for resource cleanup
‚úÖ Circular dependency resolution strategies
‚úÖ Comprehensive testing with DI
‚úÖ Best practices for production deployment</p>
    <section><title>What&apos;s Next?</title></section>
    <p>In <b>Chapter 4: Tool Orchestration and Execution ‚Üí</b>, we&apos;ll explore how AI agents execute tools, manage dependencies, handle parallel execution, and implement interactive approval systems.</p>
    <p><b>Key topics</b>:
- Tool interface design
- Dependency resolution between tools
- Parallel execution engine
- Result caching
- Interactive approval workflow
- Error handling and recovery</p>
    <p><b>Chapter 3 Progress</b>: Complete ‚úÖ
- 3.1 Why Dependency Injection? ‚úÖ
- 3.2 Container Architecture ‚úÖ
- 3.3 Service Registry Pattern ‚úÖ
- 3.4 IDisposable Pattern ‚úÖ
- 3.5 Circular Dependency Resolution ‚úÖ
- 3.6 Testing with DI ‚úÖ
- 3.7 Best Practices ‚úÖ
- Exercises (5) ‚úÖ</p>
    <p><b>Total</b>: ~3,850 lines | ~85-90 pages</p>
    <p><i>Continue to Chapter 4: Tool Orchestration and Execution ‚Üí</i></p>
  </body>
</topic>